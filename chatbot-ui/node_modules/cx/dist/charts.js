import {
	PureContainer,
	Widget,
	getContent,
	Selection,
	withHoverSync,
	Container,
	VDOM,
	CSS,
	Format as Format$1,
} from "cx/ui";
import {
	isNumber,
	isArray,
	isUndefined,
	parseStyle,
	shallowEquals,
	debug,
	isDefined,
	isNonEmptyArray,
	stopPropagation,
	closest,
	getTopLevelBoundingClientRect,
	Format,
	zeroTime,
	Console as Console$1,
} from "cx/util";
import { jsx, jsxs } from "react/jsx-runtime";
import {
	tooltipMouseMove,
	tooltipMouseLeave,
	HtmlElement,
	tooltipParentWillUnmount,
	tooltipParentWillReceiveProps,
	tooltipParentDidMount,
	tooltipParentDidUpdate,
	captureMouseOrTouch,
	getCursorPos,
} from "cx/widgets";

function _arrayLikeToArray(r, a) {
	(null == a || a > r.length) && (a = r.length);
	for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
	return n;
}
function _createForOfIteratorHelperLoose(r, e) {
	var t = ("undefined" != typeof Symbol && r[Symbol.iterator]) || r["@@iterator"];
	if (t) return (t = t.call(r)).next.bind(t);
	if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e) {
		t && (r = t);
		var o = 0;
		return function () {
			return o >= r.length
				? {
						done: !0,
					}
				: {
						done: !1,
						value: r[o++],
					};
		};
	}
	throw new TypeError(
		"Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.",
	);
}
function _extends() {
	return (
		(_extends = Object.assign
			? Object.assign.bind()
			: function (n) {
					for (var e = 1; e < arguments.length; e++) {
						var t = arguments[e];
						for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
					}
					return n;
				}),
		_extends.apply(null, arguments)
	);
}
function _inheritsLoose(t, o) {
	(t.prototype = Object.create(o.prototype)), (t.prototype.constructor = t), _setPrototypeOf(t, o);
}
function _setPrototypeOf(t, e) {
	return (
		(_setPrototypeOf = Object.setPrototypeOf
			? Object.setPrototypeOf.bind()
			: function (t, e) {
					return (t.__proto__ = e), t;
				}),
		_setPrototypeOf(t, e)
	);
}
function _unsupportedIterableToArray(r, a) {
	if (r) {
		if ("string" == typeof r) return _arrayLikeToArray(r, a);
		var t = {}.toString.call(r).slice(8, -1);
		return (
			"Object" === t && r.constructor && (t = r.constructor.name),
			"Map" === t || "Set" === t
				? Array.from(r)
				: "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t)
					? _arrayLikeToArray(r, a)
					: void 0
		);
	}
}

var Rect = /*#__PURE__*/ (function () {
	function Rect(config) {
		Object.assign(this, config);
	}
	var _proto = Rect.prototype;
	_proto.width = function width() {
		return this.r - this.l;
	};
	_proto.height = function height() {
		return this.b - this.t;
	};
	_proto.valid = function valid() {
		return this.r > this.l && this.b > this.t;
	};
	_proto.makeValid = function makeValid() {
		return new Rect({
			l: Math.min(this.l, this.r),
			r: Math.max(this.l, this.r),
			t: Math.min(this.t, this.b),
			b: Math.max(this.t, this.b),
		});
	};
	_proto.isEqual = function isEqual(r) {
		if (!r || !r.isRect) return false;
		return r.l == this.l && r.r == this.r && r.t == this.t && r.b == this.b;
	};
	Rect.add = function add(a, b) {
		return new Rect({
			l: a.l + b.l,
			t: a.t + b.t,
			r: a.r + b.r,
			b: a.b + b.b,
		});
	};
	Rect.multiply = function multiply(a, b) {
		return new Rect({
			l: a.l + (a.r - a.l) * b.l,
			r: a.l + (a.r - a.l) * b.r,
			t: a.t + (a.b - a.t) * b.t,
			b: a.t + (a.b - a.t) * b.b,
		});
	};
	Rect.margin = function margin(r, m) {
		var mr = Rect.convertMargin(m);
		return Rect.add(r, mr);
	};
	Rect.convertMargin = function convertMargin(m) {
		if (!m) return new Rect();
		if (m.isRect) return m;
		if (isNumber(m))
			return new Rect({
				l: m,
				t: m,
				r: -m,
				b: -m,
			});
		var m = Rect.convert(m);
		m.b = -m.b;
		m.r = -m.r;
		return m;
	};
	Rect.convert = function convert(r) {
		if (!r)
			return new Rect({
				l: 0,
				r: 0,
				t: 0,
				b: 0,
			});
		if (r.isRect) return r;
		if (typeof r === "string") r = r.split(" ");
		if (isArray(r)) {
			return new Rect({
				t: parseFloat(r[0]),
				r: parseFloat(r[1]),
				b: parseFloat(r[2]),
				l: parseFloat(r[3]),
			});
		}
		return new Rect(r);
	};
	return Rect;
})();
Rect.prototype.isRect = true;
Rect.prototype.l = 0; //left;
Rect.prototype.r = 0; //right
Rect.prototype.t = 0; //top
Rect.prototype.b = 0; //bottom

var BoundedObject = /*#__PURE__*/ (function (_PureContainer) {
	function BoundedObject() {
		return _PureContainer.apply(this, arguments) || this;
	}
	_inheritsLoose(BoundedObject, _PureContainer);
	var _proto = BoundedObject.prototype;
	_proto.declareData = function declareData() {
		var _PureContainer$protot;
		return (_PureContainer$protot = _PureContainer.prototype.declareData).call.apply(
			_PureContainer$protot,
			[
				this,
				{
					anchors: undefined,
					offset: undefined,
					margin: undefined,
					padding: undefined,
				},
			].concat(Array.prototype.slice.call(arguments)),
		);
	};
	_proto.prepareData = function prepareData(context, instance) {
		_PureContainer.prototype.prepareData.call(this, context, instance);
		var data = instance.data;
		data.anchors = Rect.convert(data.anchors);
		data.offset = Rect.convert(data.offset);
		data.margin = Rect.convertMargin(data.margin);
		data.padding = Rect.convertMargin(data.padding);
	};
	_proto.calculateBounds = function calculateBounds(context, instance) {
		var data = instance.data;
		return Rect.add(Rect.add(Rect.multiply(instance.parentRect, data.anchors), data.offset), data.margin);
	};
	_proto.prepareBounds = function prepareBounds(context, instance) {
		var data = instance.data;
		if (
			instance.shouldUpdate ||
			!instance.cached.parentRect ||
			!instance.cached.parentRect.isEqual(context.parentRect) ||
			!data.bounds
		) {
			if (!context.parentRect) throw new Error("Parent bounds were not provided through the context.");
			instance.parentRect = context.parentRect;
			instance.cache("parentRect", context.parentRect);
			instance.markShouldUpdate(context);
			data.bounds = this.calculateBounds(context, instance);
			data.childrenBounds = Rect.add(data.bounds, data.padding);
		}
	};
	_proto.prepare = function prepare(context, instance) {
		this.prepareBounds(context, instance);
		context.push("parentRect", instance.data.childrenBounds);
	};
	_proto.prepareCleanup = function prepareCleanup(context, instance) {
		context.pop("parentRect");
	};
	return BoundedObject;
})(PureContainer);
BoundedObject.prototype.anchors = 0;
BoundedObject.prototype.margin = 0;
BoundedObject.prototype.offset = 0;
BoundedObject.prototype.padding = 0;
BoundedObject.prototype.isPureContainer = false;
BoundedObject.prototype.styled = true;

var Axis = /*#__PURE__*/ (function (_BoundedObject) {
	function Axis() {
		return _BoundedObject.apply(this, arguments) || this;
	}
	_inheritsLoose(Axis, _BoundedObject);
	var _proto = Axis.prototype;
	_proto.init = function init() {
		if (this.labelAnchor == "auto") this.labelAnchor = this.vertical ? (this.secondary ? "start" : "end") : "middle";
		if (this.labelDx == "auto") this.labelDx = 0;
		if (this.labelDy == "auto") this.labelDy = this.vertical ? "0.4em" : this.secondary ? 0 : "0.8em";
		if (isUndefined(this.minLabelDistance))
			this.minLabelDistance = this.vertical ? this.minLabelDistanceVertical : this.minLabelDistanceHorizontal;
		if (this.labelLineCountDyFactor == "auto")
			this.labelLineCountDyFactor = this.vertical ? -this.labelLineHeight / 2 : this.secondary ? -1 : 0;
		this.lineStyle = parseStyle(this.lineStyle);
		this.tickStyle = parseStyle(this.tickStyle);
		this.labelStyle = parseStyle(this.labelStyle);
		_BoundedObject.prototype.init.call(this);
	};
	_proto.declareData = function declareData() {
		var _BoundedObject$protot;
		(_BoundedObject$protot = _BoundedObject.prototype.declareData).call.apply(
			_BoundedObject$protot,
			[
				this,
				{
					anchors: undefined,
					hideLabels: undefined,
					hideLine: undefined,
					hideTicks: undefined,
					labelRotation: undefined,
					labelAnchor: undefined,
					lineStyle: undefined,
					lineClass: undefined,
					labelStyle: undefined,
					labelClass: undefined,
					tickStyle: undefined,
					tickClass: undefined,
				},
			].concat(Array.prototype.slice.call(arguments)),
		);
	};
	_proto.prepareData = function prepareData(context, instance) {
		_BoundedObject.prototype.prepareData.call(this, context, instance);
		if (this.onCreateLabelFormatter)
			instance.labelFormatter = instance.invoke("onCreateLabelFormatter", context, instance);
	};
	_proto.report = function report(context, instance) {
		return instance.calculator;
	};
	_proto.reportData = function reportData(context, instance) {};
	_proto.renderTicksAndLabels = function renderTicksAndLabels(context, instance, valueFormatter, minLabelDistance) {
		var _this = this;
		if (this.hidden) return false;
		var data = instance.data,
			calculator = instance.calculator,
			labelFormatter = instance.labelFormatter;
		var bounds = data.bounds;
		var CSS = this.CSS,
			baseClass = this.baseClass;
		var size = calculator.findTickSize(minLabelDistance);
		var labelClass = CSS.expand(CSS.element(baseClass, "label"), data.labelClass);
		var offsetClass = CSS.element(baseClass, "label-offset");
		var x1,
			y1,
			x2,
			y2,
			tickSize = this.tickSize,
			tickOffset = this.tickOffset;
		if (this.vertical) {
			x1 = x2 = this.secondary ? bounds.r : bounds.l;
			y1 = bounds.b;
			y2 = bounds.t;
		} else {
			x1 = bounds.l;
			x2 = bounds.r;
			y1 = y2 = this.secondary ? bounds.t : bounds.b;
		}
		var res = [null, null];
		if (!data.hideLine) {
			res[0] = /*#__PURE__*/ jsx(
				"line",
				{
					className: CSS.expand(CSS.element(baseClass, "line"), data.lineClass),
					style: data.lineStyle,
					x1: x1,
					y1: y1,
					x2: x2,
					y2: y2,
				},
				"line",
			);
		}
		var t = [];
		if (!!size && !data.hideLabels) {
			var ticks = calculator.getTicks([size]);
			ticks.forEach(function (serie, si) {
				serie.forEach(function (v, i) {
					var s = calculator.map(v);
					if (_this.secondary) {
						x1 = _this.vertical ? bounds.r + tickOffset : s;
						y1 = _this.vertical ? s : bounds.t - tickOffset;
						x2 = _this.vertical ? bounds.r + tickOffset + tickSize : s;
						y2 = _this.vertical ? s : bounds.t - tickOffset - tickSize;
					} else {
						x1 = _this.vertical ? bounds.l - tickOffset : s;
						y1 = _this.vertical ? s : bounds.b + tickOffset;
						x2 = _this.vertical ? bounds.l - tickOffset - tickSize : s;
						y2 = _this.vertical ? s : bounds.b + tickOffset + tickSize;
					}
					if (!_this.useGridlineTicks) t.push("M " + x1 + " " + y1 + " L " + x2 + " " + y2);
					var x, y;
					var labelOffset =
						_this.alternateLabelOffset != null && i % 2 == 1 ? _this.alternateLabelOffset : _this.labelOffset;
					if (_this.secondary) {
						x = _this.vertical ? bounds.r + labelOffset : s;
						y = _this.vertical ? s : bounds.t - labelOffset;
					} else {
						x = _this.vertical ? bounds.l - labelOffset : s;
						y = _this.vertical ? s : bounds.b + labelOffset;
					}
					var transform = data.labelRotation ? "rotate(" + data.labelRotation + " " + x + " " + y + ")" : null;
					var formattedValue = valueFormatter(v);
					var lines = labelFormatter
						? labelFormatter(formattedValue, v, {
								tickIndex: si,
								serieIndex: i,
							})
						: _this.wrapLines(formattedValue);
					res.push(
						/*#__PURE__*/ jsx(
							"text",
							{
								className: labelClass,
								style: data.labelStyle,
								x: x,
								y: y,
								textAnchor: data.labelAnchor,
								transform: transform,
								children: _this.renderLabels(lines, x, _this.labelDy, _this.labelDx, offsetClass),
							},
							"label-" + si + "-" + i,
						),
					);
				});
			});
		}
		if (!data.hideTicks) {
			if (this.useGridlineTicks) {
				var gridlines = calculator.mapGridlines();
				gridlines.forEach(function (s, i) {
					if (_this.secondary) {
						x1 = _this.vertical ? bounds.r + tickOffset : s;
						y1 = _this.vertical ? s : bounds.t - tickOffset;
						x2 = _this.vertical ? bounds.r + tickOffset + tickSize : s;
						y2 = _this.vertical ? s : bounds.t - tickOffset - tickSize;
					} else {
						x1 = _this.vertical ? bounds.l - tickOffset : s;
						y1 = _this.vertical ? s : bounds.b + tickOffset;
						x2 = _this.vertical ? bounds.l - tickOffset - tickSize : s;
						y2 = _this.vertical ? s : bounds.b + tickOffset + tickSize;
					}
					t.push("M " + x1 + " " + y1 + " L " + x2 + " " + y2);
				});
			}
			res[1] = /*#__PURE__*/ jsx(
				"path",
				{
					className: CSS.expand(CSS.element(baseClass, "ticks"), data.tickClass),
					style: data.tickStyle,
					d: t.join(" "),
				},
				"ticks",
			);
		}
		return res;
	};
	_proto.wrapLines = function wrapLines(str) {
		if (!this.labelWrap || typeof str != "string")
			return [
				{
					text: str,
				},
			];
		var parts = str.split(" ");
		if (parts.length == 0) return null;
		var lines = [];
		var line = null;
		for (var i = 0; i < parts.length; i++) {
			if (!line) line = parts[i];
			else if (parts[i].length + line.length < this.labelMaxLineLength) line += " " + parts[i];
			else {
				lines.push({
					text: line,
				});
				line = parts[i];
			}
		}
		lines.push({
			text: line,
		});
		return lines;
	};
	_proto.renderLabels = function renderLabels(lines, x, dy, dx, offsetClass) {
		var _this2 = this;
		var offset = this.labelLineCountDyFactor * (lines.length - 1);
		var result = [];
		if (lines.length > 1 && dy != null) {
			result.push(
				/*#__PURE__*/ jsx(
					"tspan",
					{
						className: offsetClass,
						dy: dy,
						children: "_",
					},
					-2,
				),
			);
		}
		lines.forEach(function (p, i) {
			result.push(
				/*#__PURE__*/ jsx(
					"tspan",
					{
						dy: lines.length > 1 ? (i == 0 ? offset : _this2.labelLineHeight) + "em" : dy,
						x: x,
						style: p.style,
						className: p.className,
						dx: dx,
						children: p.text,
					},
					i,
				),
			);
		});
		return result;
	};
	_proto.prepare = function prepare(context, instance) {
		_BoundedObject.prototype.prepare.call(this, context, instance);
		var bounds = instance.data.bounds;
		var _ref = !this.vertical ? [bounds.l, bounds.r] : [bounds.b, bounds.t],
			a = _ref[0],
			b = _ref[1];
		instance.calculator.measure(a, b);
		if (this.onMeasured) instance.invoke("onMeasured", instance.calculator.hash(), instance);
		if (!instance.calculator.isSame(instance.cached.axis)) instance.markShouldUpdate(context);
	};
	_proto.cleanup = function cleanup(context, instance) {
		var cached = instance.cached,
			calculator = instance.calculator;
		cached.axis = calculator.hash();
	};
	return Axis;
})(BoundedObject);
Axis.prototype.anchors = "0 1 1 0";
Axis.prototype.styled = true;
Axis.prototype.vertical = false;
Axis.prototype.secondary = false;
Axis.prototype.inverted = false;
Axis.prototype.hidden = false;
Axis.prototype.hideLabels = false;
Axis.prototype.hideTicks = false;
Axis.prototype.hideLine = false;
Axis.prototype.tickSize = 3;
Axis.prototype.tickOffset = 0;
Axis.prototype.minTickDistance = 25;
Axis.prototype.minLabelDistanceVertical = 40;
Axis.prototype.minLabelDistanceHorizontal = 50;
Axis.prototype.labelOffset = 10;
Axis.prototype.alternateLabelOffset = null;
Axis.prototype.labelRotation = 0;
Axis.prototype.labelAnchor = "auto";
Axis.prototype.labelDx = "auto";
Axis.prototype.labelDy = "auto";
Axis.prototype.labelWrap = false;
Axis.prototype.labelLineCountDyFactor = "auto";
Axis.prototype.labelLineHeight = 1;
Axis.prototype.labelMaxLineLength = 10;
Axis.namespace = "ui.svg.chart.axis";

var Chart = /*#__PURE__*/ (function (_BoundedObject) {
	function Chart() {
		return _BoundedObject.apply(this, arguments) || this;
	}
	_inheritsLoose(Chart, _BoundedObject);
	var _proto = Chart.prototype;
	_proto.init = function init() {
		_BoundedObject.prototype.init.call(this);
		if (!this.axes) this.axes = {};
		for (var axis in this.axes) {
			this.axes[axis] = Axis.create(this.axes[axis]);
		}
	};
	_proto.explore = function explore(context, instance) {
		instance.calculators = _extends({}, context.axes);
		context.push("axes", instance.calculators);
		instance.axes = {};

		//axes need to be registered before children to be processed first
		for (var axis in this.axes) {
			var axisInstance = instance.getChild(context, this.axes[axis]);
			if (axisInstance.scheduleExploreIfVisible(context)) {
				instance.axes[axis] = axisInstance;
				instance.calculators[axis] = this.axes[axis].report(context, axisInstance);
			}
		}
		_BoundedObject.prototype.explore.call(this, context, instance);
	};
	_proto.exploreCleanup = function exploreCleanup(context, instance) {
		context.pop("axes");
		for (var axis in instance.axes) {
			instance.axes[axis].widget.reportData(context, instance.axes[axis]);
		}
	};
	_proto.prepare = function prepare(context, instance) {
		context.push("axes", instance.calculators);
		_BoundedObject.prototype.prepare.call(this, context, instance);
	};
	_proto.prepareCleanup = function prepareCleanup(context, instance) {
		context.pop("axes");
		_BoundedObject.prototype.prepareCleanup.call(this, context, instance);
	};
	_proto.render = function render(context, instance, key) {
		var axes = [];
		for (var k in instance.axes) {
			axes.push(getContent(instance.axes[k].render(context, key + "-axis-" + k)));
		}
		var result = [];
		if (!this.axesOnTop) result.push(axes);
		result.push(this.renderChildren(context, instance));
		if (this.axesOnTop) result.push(axes);
		return result;
	};
	return Chart;
})(BoundedObject);
Chart.prototype.anchors = "0 1 1 0";
Chart.prototype.styled = true;
Chart.prototype.isPureContainer = true;
Chart.prototype.axesOnTop = false;
Widget.alias("chart", Chart);

var PieChart = /*#__PURE__*/ (function (_BoundedObject) {
	function PieChart() {
		return _BoundedObject.apply(this, arguments) || this;
	}
	_inheritsLoose(PieChart, _BoundedObject);
	var _proto = PieChart.prototype;
	_proto.declareData = function declareData() {
		var _BoundedObject$protot;
		(_BoundedObject$protot = _BoundedObject.prototype.declareData).call.apply(
			_BoundedObject$protot,
			[this].concat(Array.prototype.slice.call(arguments), [
				{
					angle: undefined,
					startAngle: undefined,
					clockwise: undefined,
					gap: undefined,
				},
			]),
		);
	};
	_proto.explore = function explore(context, instance) {
		if (!instance.pie) instance.pie = new PieCalculator();
		var data = instance.data;
		instance.pie.reset(data.angle, data.startAngle, data.clockwise, data.gap);
		context.push("pie", instance.pie);
		_BoundedObject.prototype.explore.call(this, context, instance);
	};
	_proto.exploreCleanup = function exploreCleanup(context, instance) {
		context.pop("pie");
	};
	_proto.prepare = function prepare(context, instance) {
		this.prepareBounds(context, instance);
		var data = instance.data,
			pie = instance.pie;
		pie.measure(data.bounds);
		var hash = pie.hash();
		instance.cache("hash", hash);
		pie.shouldUpdate = !shallowEquals(hash, instance.cached.hash);
		if (!pie.shouldUpdate) instance.markShouldUpdate(context);
		_BoundedObject.prototype.prepare.call(this, context, instance);
	};
	return PieChart;
})(BoundedObject);
PieChart.prototype.anchors = "0 1 1 0";
var PieCalculator = /*#__PURE__*/ (function () {
	function PieCalculator() {}
	var _proto2 = PieCalculator.prototype;
	_proto2.reset = function reset(angle, startAngle, clockwise, gap) {
		if (angle == 360) angle = 359.99; // really hacky way to draw full circles
		this.angleTotal = (angle / 180) * Math.PI;
		this.startAngle = (startAngle / 180) * Math.PI;
		this.clockwise = clockwise;
		this.gap = gap;
		this.stacks = {};
	};
	_proto2.acknowledge = function acknowledge(stack, value, r, r0, percentageRadius) {
		var s = this.stacks[stack];
		if (!s)
			s = this.stacks[stack] = {
				total: 0,
				r0s: this.gap > 0 ? [] : null,
				r0ps: this.gap > 0 ? [] : null,
			};
		if (value > 0) {
			s.total += value;
			if (this.gap > 0 && r0 > 0)
				if (percentageRadius) s.r0ps.push(r0);
				else s.r0s.push(r0);
		}
	};
	_proto2.hash = function hash() {
		var _this = this;
		return {
			angleTotal: this.angleTotal,
			startAngle: this.startAngle,
			clockwise: this.clockwise,
			stacks: Object.keys(this.stacks)
				.map(function (s) {
					return "" + _this.stacks[s].angleFactor;
				})
				.join(":"),
			cx: this.cx,
			cy: this.cy,
			R: this.R,
			gap: this.gap,
		};
	};
	_proto2.measure = function measure(rect) {
		this.R = Math.max(0, Math.min(rect.width(), rect.height())) / 2;
		for (var s in this.stacks) {
			var stack = this.stacks[s];
			var gapAngleTotal = 0;
			stack.gap = this.gap;
			if (this.gap > 0) {
				// gap cannot be larger of two times the smallest r0
				for (var index = 0; index < stack.r0s.length; index++)
					if (2 * stack.r0s[index] < stack.gap) stack.gap = 2 * stack.r0s[index];
				for (var _index = 0; _index < stack.r0ps.length; _index++) {
					var r0 = (stack.r0ps[_index] * this.R) / 100;
					if (2 * r0 < stack.gap) stack.gap = 2 * r0;
				}
			}
			while (stack.gap > 0) {
				for (var _index2 = 0; _index2 < stack.r0s.length; _index2++)
					gapAngleTotal += 2 * Math.asin(stack.gap / stack.r0s[_index2] / 2);
				for (var _index3 = 0; _index3 < stack.r0ps.length; _index3++)
					gapAngleTotal += 2 * Math.asin(stack.gap / ((stack.r0ps[_index3] * this.R) / 100) / 2);
				if (gapAngleTotal < 0.25 * this.angleTotal) break;
				stack.gap = stack.gap * 0.95;
				gapAngleTotal = 0;
			}
			if (gapAngleTotal == 0) stack.gap = 0;
			stack.angleFactor = stack.total > 0 ? (this.angleTotal - gapAngleTotal) / stack.total : 0;
			stack.lastAngle = this.startAngle;
		}
		this.cx = (rect.l + rect.r) / 2;
		this.cy = (rect.t + rect.b) / 2;
	};
	_proto2.map = function map(stack, value, r, r0, percentageRadius) {
		if (percentageRadius) {
			r = (r * this.R) / 100;
			r0 = (r0 * this.R) / 100;
		}
		var s = this.stacks[stack];
		var angle = value * s.angleFactor;
		var startAngle = s.lastAngle;
		var clockFactor = this.clockwise ? -1 : 1;
		var gapAngle = r0 > 0 && s.gap > 0 ? 2 * Math.asin(s.gap / r0 / 2) : 0;
		s.lastAngle += clockFactor * (angle + gapAngle);
		var endAngle = startAngle + clockFactor * (angle + gapAngle);
		return {
			startAngle: startAngle,
			endAngle: startAngle + clockFactor * (angle + gapAngle),
			angle: angle,
			midAngle: (startAngle + endAngle) / 2,
			gap: s.gap,
			cx: this.cx,
			cy: this.cy,
			R: this.R,
		};
	};
	return PieCalculator;
})();
function createSvgArc(cx, cy, r0, r, startAngle, endAngle, br, gap) {
	if (r0 === void 0) {
		r0 = 0;
	}
	if (br === void 0) {
		br = 0;
	}
	if (gap === void 0) {
		gap = 0;
	}
	var gap2 = gap / 2;
	if (startAngle > endAngle) {
		var s = startAngle;
		startAngle = endAngle;
		endAngle = s;
	}
	var path = [];
	// limit br size based on r and r0
	if (br > (r - r0) / 2) br = (r - r0) / 2;
	if (br > 0) {
		if (r0 > 0) {
			var innerBr = br;
			var innerSmallArcAngle = Math.asin((br + gap2) / (r0 + br));

			// adjust br according to the available area
			if (innerSmallArcAngle > (endAngle - startAngle) / 2) {
				innerSmallArcAngle = (endAngle - startAngle) / 2;
				var sin = Math.sin(innerSmallArcAngle);
				innerBr = Math.max((r0 * sin - gap2) / (1 - sin), 0);
			}
			var innerHipDiagonal = (r0 + innerBr) * Math.cos(innerSmallArcAngle);
			var innerSmallArc1XFrom = cx + Math.cos(endAngle) * innerHipDiagonal + Math.cos(endAngle - Math.PI / 2) * gap2;
			var innerSmallArc1YFrom = cy - Math.sin(endAngle) * innerHipDiagonal - Math.sin(endAngle - Math.PI / 2) * gap2;

			// move from the first small inner arc
			path.push(move(innerSmallArc1XFrom, innerSmallArc1YFrom));
			var innerSmallArc1XTo = cx + Math.cos(endAngle - innerSmallArcAngle) * r0;
			var innerSmallArc1YTo = cy - Math.sin(endAngle - innerSmallArcAngle) * r0;

			// add first small inner arc
			path.push(arc(innerBr, innerBr, 0, 0, 0, innerSmallArc1XTo, innerSmallArc1YTo));

			// SECOND ARC

			var innerArcXTo = cx + Math.cos(startAngle + innerSmallArcAngle) * r0;
			var innerArcYTo = cy - Math.sin(startAngle + innerSmallArcAngle) * r0;
			// add large inner arc
			path.push(
				arc(
					r0,
					r0,
					0,
					largeArcFlag(endAngle - innerSmallArcAngle - startAngle - innerSmallArcAngle),
					1,
					innerArcXTo,
					innerArcYTo,
				),
			);
			var innerSmallArc2XTo = cx + Math.cos(startAngle) * innerHipDiagonal + Math.cos(startAngle + Math.PI / 2) * gap2;
			var innerSmallArc2YTo = cy - Math.sin(startAngle) * innerHipDiagonal - Math.sin(startAngle + Math.PI / 2) * gap2;
			// add second small inner arc
			path.push(arc(innerBr, innerBr, 0, 0, 0, innerSmallArc2XTo, innerSmallArc2YTo));
		} else {
			path.push(move(cx, cy));
		}
		var outerBr = br;
		var outerSmallArcAngle = Math.asin((br + gap2) / (r - br));

		// tweak br according to the available area
		if (outerSmallArcAngle > (endAngle - startAngle) / 2) {
			outerSmallArcAngle = (endAngle - startAngle) / 2;
			var _sin = Math.sin(outerSmallArcAngle);
			outerBr = Math.max((r * _sin - gap2) / (1 + _sin), 0);
		}
		var outerHipDiagonal = Math.cos(outerSmallArcAngle) * (r - outerBr);
		var outerSmallArc1XFrom = cx + Math.cos(startAngle) * outerHipDiagonal + Math.cos(startAngle + Math.PI / 2) * gap2;
		var outerSmallArc1YFrom = cy - Math.sin(startAngle) * outerHipDiagonal - Math.sin(startAngle + Math.PI / 2) * gap2;
		var outerSmallArc1XTo = cx + Math.cos(startAngle + outerSmallArcAngle) * r;
		var outerSmallArc1YTo = cy - Math.sin(startAngle + outerSmallArcAngle) * r;
		var outerLargeArcXTo = cx + Math.cos(endAngle - outerSmallArcAngle) * r;
		var outerLargeArcYTo = cy - Math.sin(endAngle - outerSmallArcAngle) * r;
		var outerSmallArc2XTo = cx + Math.cos(endAngle) * outerHipDiagonal + Math.cos(endAngle - Math.PI / 2) * gap2;
		var outerSmallArc2YTo = cy - Math.sin(endAngle) * outerHipDiagonal - Math.sin(endAngle - Math.PI / 2) * gap2;
		path.push(
			line$1(outerSmallArc1XFrom, outerSmallArc1YFrom),
			arc(outerBr, outerBr, 0, 0, 0, outerSmallArc1XTo, outerSmallArc1YTo),
			arc(
				r,
				r,
				0,
				largeArcFlag(endAngle - outerSmallArcAngle - startAngle - outerSmallArcAngle),
				0,
				outerLargeArcXTo,
				outerLargeArcYTo,
			),
			arc(outerBr, outerBr, 0, 0, 0, outerSmallArc2XTo, outerSmallArc2YTo),
		);
	} else {
		if (r0 > 0) {
			var innerGapAngle = r0 > 0 && gap2 > 0 ? Math.asin(gap2 / r0) : 0;
			var innerStartAngle = startAngle + innerGapAngle;
			var innerEndAngle = endAngle - innerGapAngle;
			var startX = cx + Math.cos(innerEndAngle) * r0;
			var startY = cy - Math.sin(innerEndAngle) * r0;
			path.push(move(startX, startY));
			var innerArcToX = cx + Math.cos(innerStartAngle) * r0;
			var innerArcToY = cy - Math.sin(innerStartAngle) * r0;
			path.push(arc(r0, r0, 0, largeArcFlag(innerStartAngle - innerEndAngle), 1, innerArcToX, innerArcToY));
		} else {
			path.push(move(cx, cy));
		}
		var outerGapAngle = r > 0 && gap2 > 0 ? Math.asin(gap2 / r) : 0;
		var outerStartAngle = startAngle + outerGapAngle;
		var outerEndAngle = endAngle - outerGapAngle;
		var lineToX = cx + Math.cos(outerStartAngle) * r;
		var lineToY = cy - Math.sin(outerStartAngle) * r;
		path.push(line$1(lineToX, lineToY));
		var arcToX = cx + Math.cos(outerEndAngle) * r;
		var arcToY = cy - Math.sin(outerEndAngle) * r;
		path.push(arc(r, r, 0, largeArcFlag(outerEndAngle - outerStartAngle), 0, arcToX, arcToY));
	}
	path.push(z());
	return path.join(" ");
}
PieChart.prototype.anchors = "0 1 1 0";
PieChart.prototype.angle = 360;
PieChart.prototype.startAngle = 0;
PieChart.prototype.gap = 0;
Widget.alias("pie-slice");
var PieSlice = /*#__PURE__*/ (function (_Container) {
	function PieSlice() {
		return _Container.apply(this, arguments) || this;
	}
	_inheritsLoose(PieSlice, _Container);
	var _proto3 = PieSlice.prototype;
	_proto3.init = function init() {
		this.selection = Selection.create(this.selection);
		if (this.borderRadius) this.br = this.borderRadius;
		_Container.prototype.init.call(this);
	};
	_proto3.declareData = function declareData() {
		var _Container$prototype$;
		var selection = this.selection.configureWidget(this);
		(_Container$prototype$ = _Container.prototype.declareData).call.apply(
			_Container$prototype$,
			[this].concat(Array.prototype.slice.call(arguments), [
				selection,
				{
					active: true,
					r0: undefined,
					r: undefined,
					colorIndex: undefined,
					colorMap: undefined,
					colorName: undefined,
					offset: undefined,
					value: undefined,
					disabled: undefined,
					innerPointRadius: undefined,
					outerPointRadius: undefined,
					name: undefined,
					stack: undefined,
					legend: undefined,
					hoverId: undefined,
					br: undefined,
					legendDisplayText: undefined,
				},
			]),
		);
	};
	_proto3.prepareData = function prepareData(context, instance) {
		var data = instance.data;
		if (data.name && !data.colorName) data.colorName = data.name;
		_Container.prototype.prepareData.call(this, context, instance);
	};
	_proto3.explore = function explore(context, instance) {
		instance.pie = context.pie;
		if (!instance.pie) throw new Error("Pie.Slice must be placed inside a Pie.");
		var data = instance.data;
		instance.valid = isNumber(data.value) && data.value > 0;
		instance.colorMap = data.colorMap && context.getColorMap && context.getColorMap(data.colorMap);
		if (instance.colorMap && data.colorName) instance.colorMap.acknowledge(data.colorName);
		instance.hoverSync = context.hoverSync;
		if (instance.valid && data.active) {
			instance.pie.acknowledge(data.stack, data.value, data.r, data.r0, this.percentageRadius);
			_Container.prototype.explore.call(this, context, instance);
		}
	};
	_proto3.prepare = function prepare(context, instance) {
		var _this2 = this;
		var data = instance.data,
			segment = instance.segment,
			pie = instance.pie,
			colorMap = instance.colorMap;
		if (colorMap && data.colorName) {
			data.colorIndex = colorMap.map(data.colorName);
			if (instance.cache("colorIndex", data.colorIndex)) instance.markShouldUpdate(context);
		}
		if (instance.valid && data.active) {
			var seg = pie.map(data.stack, data.value, data.r, data.r0, this.percentageRadius);
			if (
				!segment ||
				instance.shouldUpdate ||
				seg.startAngle != segment.startAngle ||
				seg.endAngle != segment.endAngle ||
				pie.shouldUpdate
			) {
				if (data.offset > 0) {
					seg.ox = seg.cx + Math.cos(seg.midAngle) * data.offset;
					seg.oy = seg.cy - Math.sin(seg.midAngle) * data.offset;
				} else {
					seg.ox = seg.cx;
					seg.oy = seg.cy;
				}
				seg.radiusMultiplier = 1;
				if (this.percentageRadius) seg.radiusMultiplier = seg.R / 100;
				var innerR = data.innerPointRadius != null ? data.innerPointRadius : data.r0;
				var outerR = data.outerPointRadius != null ? data.outerPointRadius : data.r;
				var ix = seg.ox + Math.cos(seg.midAngle) * innerR * seg.radiusMultiplier;
				var iy = seg.oy - Math.sin(seg.midAngle) * innerR * seg.radiusMultiplier;
				var ox = seg.ox + Math.cos(seg.midAngle) * outerR * seg.radiusMultiplier;
				var oy = seg.oy - Math.sin(seg.midAngle) * outerR * seg.radiusMultiplier;
				instance.segment = seg;
				instance.bounds = new Rect({
					l: ix,
					r: ox,
					t: iy,
					b: oy,
				});
				instance.markShouldUpdate(context);
			}
			context.push("parentRect", instance.bounds);
		}
		if (data.name && data.legend && context.addLegendEntry)
			context.addLegendEntry(data.legend, {
				name: data.name,
				active: data.active,
				colorIndex: data.colorIndex,
				disabled: data.disabled,
				selected: this.selection.isInstanceSelected(instance),
				style: data.style,
				shape: this.legendShape,
				hoverId: data.hoverId,
				hoverChannel: this.hoverChannel,
				hoverSync: instance.hoverSync,
				displayText: data.legendDisplayText,
				onClick: function onClick(e) {
					_this2.onLegendClick(e, instance);
				},
			});
	};
	_proto3.prepareCleanup = function prepareCleanup(context, instance) {
		if (instance.valid && instance.data.active) {
			context.pop("parentRect");
		}
	};
	_proto3.onLegendClick = function onLegendClick(e, instance) {
		var allActions = this.legendAction == "auto";
		var data = instance.data;
		if (allActions || this.legendAction == "toggle") if (instance.set("active", !data.active)) return;
		if (allActions || this.legendAction == "select") this.handleClick(e, instance);
	};
	_proto3.render = function render(context, instance, key) {
		var _this3 = this;
		var segment = instance.segment,
			data = instance.data;
		if (!instance.valid || !data.active) return null;
		return withHoverSync(key, instance.hoverSync, this.hoverChannel, data.hoverId, function (_ref) {
			var _stateMods;
			var hover = _ref.hover,
				_onMouseMove = _ref.onMouseMove,
				_onMouseLeave = _ref.onMouseLeave;
			var stateMods =
				((_stateMods = {
					selected: _this3.selection.isInstanceSelected(instance),
					disabled: data.disabled,
					selectable: !_this3.selection.isDummy,
				}),
				(_stateMods["color-" + data.colorIndex] = data.colorIndex != null),
				(_stateMods.hover = hover),
				_stateMods);
			var d = createSvgArc(
				segment.ox,
				segment.oy,
				data.r0 * segment.radiusMultiplier,
				data.r * segment.radiusMultiplier,
				segment.startAngle,
				segment.endAngle,
				data.br,
				segment.gap,
			);
			return /*#__PURE__*/ jsxs(
				"g",
				{
					className: data.classNames,
					children: [
						/*#__PURE__*/ jsx("path", {
							className: _this3.CSS.element(_this3.baseClass, "slice", stateMods),
							style: data.style,
							d: d,
							onMouseMove: function onMouseMove(e) {
								_onMouseMove(e, instance);
								tooltipMouseMove(e, instance, _this3.tooltip);
							},
							onMouseLeave: function onMouseLeave(e) {
								_onMouseLeave(e, instance);
								tooltipMouseLeave(e, instance, _this3.tooltip);
							},
							onClick: function onClick(e) {
								_this3.handleClick(e, instance);
							},
						}),
						_this3.renderChildren(context, instance),
					],
				},
				key,
			);
		});
	};
	_proto3.handleClick = function handleClick(e, instance) {
		if (!this.selection.isDummy) {
			this.selection.selectInstance(instance, {
				toggle: e.ctrlKey,
			});
			e.stopPropagation();
			e.preventDefault();
		}
	};
	return PieSlice;
})(Container);
function move(x, y) {
	return "M " + x + " " + y;
}
function line$1(x, y) {
	return "L " + x + " " + y;
}
function z() {
	return "Z";
}
function arc(rx, ry, xRotation, largeArc, sweep, x, y) {
	return "A " + rx + " " + ry + " " + xRotation + " " + largeArc + " " + sweep + " " + x + " " + y;
}
function largeArcFlag(angle) {
	return angle > Math.PI || angle < -Math.PI ? 1 : 0;
}
PieSlice.prototype.offset = 0;
PieSlice.prototype.r0 = 0;
PieSlice.prototype.r = 50;
PieSlice.prototype.percentageRadius = true;
PieSlice.prototype.baseClass = "pieslice";
PieSlice.prototype.legend = "legend";
PieSlice.prototype.active = true;
PieSlice.prototype.stack = "stack";
PieSlice.prototype.legendAction = "auto";
PieSlice.prototype.legendShape = "circle";
PieSlice.prototype.hoverChannel = "default";
PieSlice.prototype.styled = true;
PieSlice.prototype.br = 0;
Widget.alias("pie-chart", PieChart);

debug("The Pie class is deprecated. Please use PieChart instead.");
var Pie = PieChart;
Pie.Slice = PieSlice;

var PieLabel = /*#__PURE__*/ (function (_BoundedObject) {
	function PieLabel() {
		return _BoundedObject.apply(this, arguments) || this;
	}
	_inheritsLoose(PieLabel, _BoundedObject);
	var _proto = PieLabel.prototype;
	_proto.init = function init() {
		this.lineStyle = parseStyle(this.lineStyle);
		_BoundedObject.prototype.init.call(this);
	};
	_proto.declareData = function declareData() {
		var _BoundedObject$protot;
		for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
			args[_key] = arguments[_key];
		}
		(_BoundedObject$protot = _BoundedObject.prototype.declareData).call.apply(
			_BoundedObject$protot,
			[this].concat(args, [
				{
					distance: undefined,
					lineStyle: {
						structured: true,
					},
					lineStroke: undefined,
					lineClass: {
						structured: true,
					},
					lineColorIndex: undefined,
				},
			]),
		);
	};
	_proto.calculateBounds = function calculateBounds(context, instance) {
		var data = instance.data;
		var bounds = Rect.add(Rect.add(Rect.multiply(instance.parentRect, data.anchors), data.offset), data.margin);
		instance.originalBounds = bounds;
		instance.actualBounds = context.placePieLabel(bounds, data.distance);
		return new Rect({
			t: 0,
			r: bounds.width(),
			b: bounds.height(),
			l: 0,
		});
	};
	_proto.prepare = function prepare(context, instance) {
		_BoundedObject.prototype.prepare.call(this, context, instance);
		if (!context.registerPieLabel)
			throw new Error("PieLabel components are allowed only within PieLabelsContainer components.");
		var right = instance.parentRect.r > instance.parentRect.l;
		context.push("textDirection", right ? "right" : "left");
		context.registerPieLabel(instance);
	};
	_proto.prepareCleanup = function prepareCleanup(context, instance) {
		context.pop("textDirection");
	};
	_proto.render = function render(context, instance, key) {
		var originalBounds = instance.originalBounds,
			actualBounds = instance.actualBounds,
			data = instance.data;
		return /*#__PURE__*/ jsxs(
			"g",
			{
				className: data.classNames,
				children: [
					/*#__PURE__*/ jsx("line", {
						className: this.CSS.element(
							this.baseClass,
							"line",
							data.lineColorIndex != null && "color-" + data.lineColorIndex,
						),
						x1: actualBounds.l < originalBounds.l ? actualBounds.r : actualBounds.l,
						y1: (actualBounds.t + actualBounds.b) / 2,
						x2: (originalBounds.l + originalBounds.r) / 2,
						y2: (originalBounds.t + originalBounds.b) / 2,
						stroke: data.lineStroke,
						style: data.lineStyle,
					}),
					/*#__PURE__*/ jsx("g", {
						transform: "translate(" + instance.actualBounds.l + " " + instance.actualBounds.t + ")",
						children: this.renderChildren(context, instance),
					}),
				],
			},
			key,
		);
	};
	return PieLabel;
})(BoundedObject);
PieLabel.prototype.distance = 100;
PieLabel.prototype.baseClass = "pielabel";
PieLabel.prototype.styled = true;

var PieLabelsContainer = /*#__PURE__*/ (function (_BoundedObject) {
	function PieLabelsContainer() {
		return _BoundedObject.apply(this, arguments) || this;
	}
	_inheritsLoose(PieLabelsContainer, _BoundedObject);
	var _proto = PieLabelsContainer.prototype;
	_proto.prepare = function prepare(context, instance) {
		_BoundedObject.prototype.prepare.call(this, context, instance);
		var bounds = instance.data.bounds;
		var cx2 = bounds.l + bounds.r;
		context.push("placePieLabel", function (labelBounds, distance) {
			var clone = new Rect(labelBounds);
			var w = clone.r - clone.l;
			if (clone.l + clone.r > cx2) {
				clone.r = Math.min(clone.r + distance, bounds.r);
				clone.l = clone.r - w;
			} else {
				clone.l = Math.max(bounds.l, clone.l - distance);
				clone.r = clone.l + w;
			}
			return clone;
		});
		instance.leftLabels = [];
		instance.rightLabels = [];
		context.push("registerPieLabel", function (label) {
			if (label.actualBounds.l + label.actualBounds.r < cx2) instance.leftLabels.push(label);
			else instance.rightLabels.push(label);
		});
	};
	_proto.prepareCleanup = function prepareCleanup(context, instance) {
		context.pop("placePieLabel");
		context.pop("registerPieLabel");
		_BoundedObject.prototype.prepareCleanup.call(this, context, instance);
		this.distributeLabels(instance.leftLabels, instance);
		this.distributeLabels(instance.rightLabels, instance);
	};
	_proto.distributeLabels = function distributeLabels(labels, instance) {
		labels.sort(function (a, b) {
			return a.actualBounds.t + a.actualBounds.b - (b.actualBounds.t + b.actualBounds.b);
		});
		var totalHeight = labels.reduce(function (h, l) {
			return h + l.actualBounds.height();
		}, 0);
		var bounds = instance.data.bounds;
		var avgHeight = Math.min(totalHeight, bounds.height()) / labels.length;
		var at = bounds.t;
		for (var i = 0; i < labels.length; i++) {
			var ab = labels[i].actualBounds;
			ab.t = Math.max(at, Math.min(ab.t, bounds.b - (labels.length - i) * avgHeight));
			ab.b = ab.t + avgHeight;
			at = ab.b;
		}
	};
	return PieLabelsContainer;
})(BoundedObject);
PieLabelsContainer.prototype.anchors = "0 1 1 0";

var ColumnBarBase = /*#__PURE__*/ (function (_PureContainer) {
	function ColumnBarBase() {
		return _PureContainer.apply(this, arguments) || this;
	}
	_inheritsLoose(ColumnBarBase, _PureContainer);
	var _proto = ColumnBarBase.prototype;
	_proto.init = function init() {
		this.selection = Selection.create(this.selection);
		_PureContainer.prototype.init.call(this);
	};
	_proto.declareData = function declareData() {
		var _PureContainer$protot;
		var selection = this.selection.configureWidget(this);
		return (_PureContainer$protot = _PureContainer.prototype.declareData).call.apply(
			_PureContainer$protot,
			[this].concat(Array.prototype.slice.call(arguments), [
				selection,
				{
					x: undefined,
					y: undefined,
					style: {
						structured: true,
					},
					class: {
						structured: true,
					},
					className: {
						structured: true,
					},
					disabled: undefined,
					colorIndex: undefined,
					colorMap: undefined,
					colorName: undefined,
					name: undefined,
					active: true,
					stacked: undefined,
					stack: undefined,
					offset: undefined,
					hoverId: undefined,
					borderRadius: undefined,
					hidden: undefined,
				},
			]),
		);
	};
	_proto.prepareData = function prepareData(context, instance) {
		instance.axes = context.axes;
		instance.xAxis = context.axes[this.xAxis];
		instance.yAxis = context.axes[this.yAxis];
		instance.hoverSync = context.hoverSync;
		var data = instance.data;
		data.valid = this.checkValid(data);
		if (!data.colorName && data.name) data.colorName = data.name;
		_PureContainer.prototype.prepareData.call(this, context, instance);
	};
	_proto.checkValid = function checkValid(data) {
		return true;
	};
	_proto.prepare = function prepare(context, instance) {
		var _this = this;
		var data = instance.data,
			colorMap = instance.colorMap;
		if (colorMap && data.colorName) {
			data.colorIndex = colorMap.map(data.colorName);
			if (instance.cache("colorIndex", data.colorIndex)) instance.markShouldUpdate(context);
		}
		if (!data.valid) return;
		if (data.active) {
			instance.bounds = this.calculateRect(instance);
			instance.cache("bounds", instance.bounds);
			if (!instance.bounds.isEqual(instance.cached.bounds)) instance.markShouldUpdate(context);
			context.push("parentRect", instance.bounds);
			if (instance.xAxis.shouldUpdate || instance.yAxis.shouldUpdate) instance.markShouldUpdate(context);
		}
		if (data.name && context.addLegendEntry)
			context.addLegendEntry(this.legend, {
				name: data.name,
				active: data.active,
				colorIndex: data.colorIndex,
				disabled: data.disabled,
				selected: this.selection.isInstanceSelected(instance),
				style: data.style,
				shape: this.legendShape,
				onClick: function onClick(e) {
					_this.onLegendClick(e, instance);
				},
			});
	};
	_proto.prepareCleanup = function prepareCleanup(context, instance) {
		var data = instance.data;
		if (data.valid && data.active) context.pop("parentRect");
	};
	_proto.onLegendClick = function onLegendClick(e, instance) {
		var allActions = this.legendAction == "auto";
		var data = instance.data;
		if (allActions || this.legendAction == "toggle") if (instance.set("active", !data.active)) return;
		if (allActions || this.legendAction == "select") this.handleClick(e, instance);
	};
	_proto.calculateRect = function calculateRect(context, instance) {
		throw new Error("Abstract method.");
	};
	_proto.render = function render(context, instance, key) {
		var _this2 = this;
		var data = instance.data,
			bounds = instance.bounds;
		if (!data.active || !data.valid) return null;
		return withHoverSync(key, instance.hoverSync, this.hoverChannel, data.hoverId, function (_ref) {
			var _stateMods;
			var hover = _ref.hover,
				_onMouseMove = _ref.onMouseMove,
				_onMouseLeave = _ref.onMouseLeave,
				key = _ref.key;
			var stateMods =
				((_stateMods = {
					selected: _this2.selection.isInstanceSelected(instance),
					disabled: data.disabled,
					selectable: !_this2.selection.isDummy,
				}),
				(_stateMods["color-" + data.colorIndex] = data.colorIndex != null),
				(_stateMods.hover = hover),
				_stateMods);
			return /*#__PURE__*/ jsxs(
				"g",
				{
					className: data.classNames,
					children: [
						!data.hidden &&
							/*#__PURE__*/ jsx("rect", {
								className: _this2.CSS.element(_this2.baseClass, "rect", stateMods),
								style: data.style,
								x: bounds.l,
								y: bounds.t,
								width: bounds.width(),
								height: bounds.height(),
								rx: data.borderRadius,
								onMouseMove: function onMouseMove(e) {
									_onMouseMove(e, instance);
									tooltipMouseMove(e, instance, _this2.tooltip);
								},
								onMouseLeave: function onMouseLeave(e) {
									_onMouseLeave(e, instance);
									tooltipMouseLeave(e, instance, _this2.tooltip);
								},
								onClick: function onClick(e) {
									_this2.handleClick(e, instance);
								},
							}),
						_this2.renderChildren(context, instance),
					],
				},
				key,
			);
		});
	};
	_proto.handleClick = function handleClick(e, instance) {
		if (!this.selection.isDummy) {
			this.selection.selectInstance(instance, {
				toggle: e.ctrlKey,
			});
			e.stopPropagation();
			e.preventDefault();
		}
	};
	return ColumnBarBase;
})(PureContainer);
ColumnBarBase.prototype.xAxis = "x";
ColumnBarBase.prototype.yAxis = "y";
ColumnBarBase.prototype.offset = 0;
ColumnBarBase.prototype.legend = "legend";
ColumnBarBase.prototype.legendAction = "auto";
ColumnBarBase.prototype.active = true;
ColumnBarBase.prototype.stacked = false;
ColumnBarBase.prototype.stack = "stack";
ColumnBarBase.prototype.legendShape = "rect";
ColumnBarBase.prototype.styled = true;
ColumnBarBase.prototype.hoverChannel = "default";
ColumnBarBase.prototype.borderRadius = 0;
ColumnBarBase.prototype.hidden = false;

var Column = /*#__PURE__*/ (function (_ColumnBarBase) {
	function Column() {
		return _ColumnBarBase.apply(this, arguments) || this;
	}
	_inheritsLoose(Column, _ColumnBarBase);
	var _proto = Column.prototype;
	_proto.init = function init() {
		if (isDefined(this.width)) this.size = this.width;
		_ColumnBarBase.prototype.init.call(this);
	};
	_proto.declareData = function declareData() {
		var _ColumnBarBase$protot;
		return (_ColumnBarBase$protot = _ColumnBarBase.prototype.declareData).call.apply(
			_ColumnBarBase$protot,
			[this].concat(Array.prototype.slice.call(arguments), [
				{
					y0: undefined,
					size: undefined,
					autoSize: undefined,
				},
			]),
		);
	};
	_proto.checkValid = function checkValid(data) {
		return data.x != null && data.y != null && data.y0 != null;
	};
	_proto.explore = function explore(context, instance) {
		var data = instance.data,
			xAxis = instance.xAxis,
			yAxis = instance.yAxis;
		instance.colorMap = data.colorMap && context.getColorMap && context.getColorMap(data.colorMap);
		if (instance.colorMap && data.colorName) instance.colorMap.acknowledge(data.colorName);
		if (!data.valid) return;
		if (data.active) {
			xAxis.acknowledge(data.x, data.size, data.offset);
			if (data.autoSize) xAxis.book(data.x, data.stacked ? data.stack : data.name);
			if (data.stacked) {
				yAxis.stacknowledge(data.stack, data.x, data.y0);
				yAxis.stacknowledge(data.stack, data.x, data.y);
			} else {
				if (!this.hiddenBase) yAxis.acknowledge(data.y0);
				yAxis.acknowledge(data.y);
			}
			_ColumnBarBase.prototype.explore.call(this, context, instance);
		}
	};
	_proto.calculateRect = function calculateRect(instance) {
		var data = instance.data;
		var offset = data.offset,
			size = data.size;
		if (data.autoSize) {
			var _instance$xAxis$locat = instance.xAxis.locate(data.x, data.stacked ? data.stack : data.name),
				index = _instance$xAxis$locat[0],
				count = _instance$xAxis$locat[1];
			offset = (size / count) * (index - count / 2 + 0.5);
			size = size / count;
		}
		var x1 = instance.xAxis.map(data.x, offset - size / 2);
		var x2 = instance.xAxis.map(data.x, offset + size / 2);
		var y1 = data.stacked ? instance.yAxis.stack(data.stack, data.x, data.y0) : instance.yAxis.map(data.y0);
		var y2 = data.stacked ? instance.yAxis.stack(data.stack, data.x, data.y) : instance.yAxis.map(data.y);
		if (Math.abs(y2 - y1) < this.minPixelHeight) {
			if (y1 < y2) y2 = y1 + this.minPixelHeight;
			else y2 = y1 - this.minPixelHeight;
		}
		var bounds = new Rect({
			l: Math.min(x1, x2),
			r: Math.max(x1, x2),
			t: Math.min(y1, y2),
			b: Math.max(y1, y2),
		});
		return bounds;
	};
	return Column;
})(ColumnBarBase);
Column.prototype.baseClass = "column";
Column.prototype.y0 = 0;
Column.prototype.size = 1;
Column.prototype.autoSize = false;
Column.prototype.legendShape = "column";
Column.prototype.hiddenBase = false;
Column.prototype.minPixelHeight = 0.5;
Widget.alias("column", Column);

var Bar = /*#__PURE__*/ (function (_ColumnBarBase) {
	function Bar() {
		return _ColumnBarBase.apply(this, arguments) || this;
	}
	_inheritsLoose(Bar, _ColumnBarBase);
	var _proto = Bar.prototype;
	_proto.init = function init() {
		if (isDefined(this.height)) this.size = this.height;
		_ColumnBarBase.prototype.init.call(this);
	};
	_proto.declareData = function declareData() {
		var _ColumnBarBase$protot;
		return (_ColumnBarBase$protot = _ColumnBarBase.prototype.declareData).call.apply(
			_ColumnBarBase$protot,
			[this].concat(Array.prototype.slice.call(arguments), [
				{
					x0: undefined,
					size: undefined,
					autoSize: undefined,
				},
			]),
		);
	};
	_proto.checkValid = function checkValid(data) {
		return data.y != null && data.x != null && data.x0 != null;
	};
	_proto.explore = function explore(context, instance) {
		var data = instance.data,
			xAxis = instance.xAxis,
			yAxis = instance.yAxis;
		instance.colorMap = data.colorMap && context.getColorMap && context.getColorMap(data.colorMap);
		if (instance.colorMap && data.colorName) instance.colorMap.acknowledge(data.colorName);
		if (!data.valid) return;
		if (data.active) {
			yAxis.acknowledge(data.y, data.size, data.offset);
			if (data.autoSize) yAxis.book(data.y, data.stacked ? data.stack : data.name);
			if (data.stacked) {
				xAxis.stacknowledge(data.stack, data.y, data.x0);
				xAxis.stacknowledge(data.stack, data.y, data.x);
			} else {
				if (!this.hiddenBase) xAxis.acknowledge(data.x0);
				xAxis.acknowledge(data.x);
			}
			_ColumnBarBase.prototype.explore.call(this, context, instance);
		}
	};
	_proto.calculateRect = function calculateRect(instance) {
		var data = instance.data;
		var offset = data.offset,
			size = data.size;
		if (data.autoSize) {
			var _instance$yAxis$locat = instance.yAxis.locate(data.y, data.stacked ? data.stack : data.name),
				index = _instance$yAxis$locat[0],
				count = _instance$yAxis$locat[1];
			offset = (size / count) * (index - count / 2 + 0.5);
			size = size / count;
		}
		var x1 = data.stacked ? instance.xAxis.stack(data.stack, data.y, data.x0) : instance.xAxis.map(data.x0);
		var x2 = data.stacked ? instance.xAxis.stack(data.stack, data.y, data.x) : instance.xAxis.map(data.x);
		var y1 = instance.yAxis.map(data.y, offset - size / 2);
		var y2 = instance.yAxis.map(data.y, offset + size / 2);
		var bounds = new Rect({
			l: Math.min(x1, x2),
			r: Math.max(x1, x2),
			t: Math.min(y1, y2),
			b: Math.max(y1, y2),
		});
		return bounds;
	};
	return Bar;
})(ColumnBarBase);
Bar.prototype.baseClass = "bar";
Bar.prototype.x0 = 0;
Bar.prototype.size = 1;
Bar.prototype.autoSize = false;
Bar.prototype.legendShape = "bar";
Bar.prototype.hiddenBase = false;
Widget.alias("bar", Bar);

var shapes = {};
var warnings = {};
function registerShape(name, callback) {
	shapes[name] = callback;
}
function getShape(shapeName) {
	if (shapes[shapeName]) return shapes[shapeName];
	if (!warnings[shapeName]) {
		warnings[shapeName] = true;
		debug("Unknown shape '" + shapeName + "'. Using square instead.");
	}
	return shapes["square"];
}
function getAvailableShapes() {
	return Object.keys(shapes);
}
function circle(cx, cy, size, props, options) {
	return /*#__PURE__*/ jsx(
		"circle",
		_extends({}, props, {
			cx: cx,
			cy: cy,
			r: size / 2,
		}),
	);
}
registerShape("circle", circle);
function square(cx, cy, size, props, options) {
	size *= 0.9;
	return /*#__PURE__*/ jsx(
		"rect",
		_extends({}, props, {
			x: cx - size / 2,
			y: cy - size / 2,
			width: size,
			height: size,
		}),
	);
}
registerShape("square", square);
registerShape("rect", square);
function bar(cx, cy, size, props, options) {
	size *= 0.9;
	return /*#__PURE__*/ jsx(
		"rect",
		_extends({}, props, {
			x: cx - size / 2,
			y: cy - size / 4,
			width: size,
			height: size / 2,
		}),
	);
}
registerShape("bar", bar);
function column(cx, cy, size, props, options) {
	size *= 0.9;
	return /*#__PURE__*/ jsx(
		"rect",
		_extends({}, props, {
			x: cx - size / 4,
			y: cy - size / 2,
			width: size / 2,
			height: size,
		}),
	);
}
registerShape("column", column);
function line(cx, cy, size, props, options) {
	size *= 0.9;
	return /*#__PURE__*/ jsx(
		"line",
		_extends({}, props, {
			x1: cx - size / 2,
			y1: cy,
			x2: cx + size / 2,
			y2: cy,
		}),
	);
}
registerShape("line", line);
registerShape("hline", line);
function vline(cx, cy, size, props, options) {
	size *= 0.9;
	return /*#__PURE__*/ jsx(
		"line",
		_extends({}, props, {
			x1: cx,
			y1: cy - size / 2,
			x2: cx,
			y2: cy + size / 2,
		}),
	);
}
registerShape("vline", vline);
function triangle(cx, cy, size, props, options) {
	size *= 1.29;
	var d = "";
	var cos = Math.cos(Math.PI / 6);
	var sin = Math.sin(Math.PI / 6);
	d += "M " + cx + " " + (cy - size / 2) + " ";
	d += "L " + (cx + (cos * size) / 2) + " " + (cy + (sin * size) / 2) + " ";
	d += "L " + (cx - (cos * size) / 2) + " " + (cy + (sin * size) / 2) + " ";
	d += "Z";
	return /*#__PURE__*/ jsx(
		"path",
		_extends({}, props, {
			d: d,
		}),
	);
}
registerShape("triangle", triangle);

var Legend = /*#__PURE__*/ (function (_HtmlElement) {
	function Legend() {
		return _HtmlElement.apply(this, arguments) || this;
	}
	_inheritsLoose(Legend, _HtmlElement);
	var _proto = Legend.prototype;
	_proto.declareData = function declareData() {
		var _HtmlElement$prototyp;
		(_HtmlElement$prototyp = _HtmlElement.prototype.declareData).call.apply(
			_HtmlElement$prototyp,
			[this].concat(Array.prototype.slice.call(arguments), [
				{
					shape: undefined,
					entryStyle: {
						structured: true,
					},
					entryClass: {
						structured: true,
					},
				},
			]),
		);
	};
	_proto.init = function init() {
		this.entryStyle = parseStyle(this.entryStyle);
		_HtmlElement.prototype.init.call(this);
	};
	_proto.prepareData = function prepareData(context, instance) {
		var data = instance.data;
		data.stateMods = Object.assign(data.stateMods || {}, {
			vertical: this.vertical,
		});
		_HtmlElement.prototype.prepareData.call(this, context, instance);
	};
	_proto.isValidHtmlAttribute = function isValidHtmlAttribute(attrName) {
		switch (attrName) {
			case "shapeSize":
			case "svgSize":
			case "shape":
			case "entryStyle":
			case "entryClass":
				return false;
			default:
				return _HtmlElement.prototype.isValidHtmlAttribute.call(this, attrName);
		}
	};
	_proto.explore = function explore(context, instance) {
		if (!context.legends) context.legends = {};
		instance.legends = context.legends;
		context.addLegendEntry = function (legendName, entry) {
			if (!legendName) return;

			//case when all legends are scoped and new entry is added outside the scope
			if (!context.legends) return;
			var legend = context.legends[legendName];
			if (!legend)
				legend = context.legends[legendName] = {
					entries: [],
					names: {},
				};
			if (!legend.names[entry.name]) {
				legend.entries.push(entry);
				legend.names[entry.name] = entry;
			}
		};
		_HtmlElement.prototype.explore.call(this, context, instance);
	};
	_proto.renderChildren = function renderChildren(context, instance) {
		var _this = this;
		var CSS = this.CSS;
		var entries = instance.legends[this.name] && instance.legends[this.name].entries,
			list;
		var _instance$data = instance.data,
			entryClass = _instance$data.entryClass,
			entryStyle = _instance$data.entryStyle,
			shape = _instance$data.shape;
		if (isNonEmptyArray(entries)) {
			list = entries.map(function (e, i) {
				return withHoverSync(i, e.hoverSync, e.hoverChannel, e.hoverId, function (_ref) {
					var onMouseMove = _ref.onMouseMove,
						onMouseLeave = _ref.onMouseLeave,
						hover = _ref.hover;
					return /*#__PURE__*/ jsxs(
						"div",
						{
							className: CSS.expand(
								CSS.element(_this.baseClass, "entry", {
									"color-root": true,
									hover: hover,
									disabled: e.disabled,
									selected: e.selected,
								}),
								entryClass,
							),
							style: entryStyle,
							onClick: e.onClick,
							onMouseMove: onMouseMove,
							onMouseLeave: onMouseLeave,
							children: [
								_this.renderShape(e, shape),
								/*#__PURE__*/ jsx("div", {
									children: e.displayText || e.name,
								}),
							],
						},
						i,
					);
				});
			});
		}
		return [list, _HtmlElement.prototype.renderChildren.call(this, context, instance)];
	};
	_proto.renderShape = function renderShape(entry, legendEntriesShape) {
		var _this$CSS$element, _style$fill, _style$stroke;
		var className = this.CSS.element(
			this.baseClass,
			"shape",
			((_this$CSS$element = {}),
			(_this$CSS$element["color-" + entry.colorIndex] =
				entry.colorIndex != null && (isUndefined(entry.active) || entry.active)),
			_this$CSS$element),
		);
		var shape = getShape(legendEntriesShape || entry.shape || "square");

		// if the entry has a custom fill or stroke set, use it for both values
		var style = _extends({}, entry.style);
		style.fill = (_style$fill = style.fill) != null ? _style$fill : style.stroke;
		style.stroke = (_style$stroke = style.stroke) != null ? _style$stroke : style.fill;
		return /*#__PURE__*/ jsx("svg", {
			className: this.CSS.element(this.baseClass, "svg"),
			style: {
				width: this.svgSize + "px",
				height: this.svgSize + "px",
			},
			children: shape(this.svgSize / 2, this.svgSize / 2, entry.shapeSize || this.shapeSize, {
				style: style,
				className: className,
			}),
		});
	};
	return Legend;
})(HtmlElement);
Legend.prototype.name = "legend";
Legend.prototype.baseClass = "legend";
Legend.prototype.vertical = false;
Legend.prototype.memoize = false;
Legend.prototype.shapeSize = 18;
Legend.prototype.shape = null;
Legend.prototype.svgSize = 20;
Widget.alias("legend", Legend);
Legend.Scope = /*#__PURE__*/ (function (_PureContainer) {
	function _class() {
		return _PureContainer.apply(this, arguments) || this;
	}
	_inheritsLoose(_class, _PureContainer);
	var _proto2 = _class.prototype;
	_proto2.explore = function explore(context, instance) {
		context.push("legends", (instance.legends = {}));
		_PureContainer.prototype.explore.call(this, context, instance);
	};
	_proto2.exploreCleanup = function exploreCleanup(context, instance) {
		context.pop("legends");
	};
	_proto2.prepare = function prepare(context, instance) {
		context.push("legends", instance.legends);
	};
	_proto2.prepareCleanup = function prepareCleanup(context, instance) {
		context.pop("legends");
	};
	return _class;
})(PureContainer);
var LegendScope = Legend.Scope;

var LegendEntry = /*#__PURE__*/ (function (_Container) {
	function LegendEntry() {
		return _Container.apply(this, arguments) || this;
	}
	_inheritsLoose(LegendEntry, _Container);
	var _proto = LegendEntry.prototype;
	_proto.init = function init() {
		this.selection = Selection.create(this.selection);
		_Container.prototype.init.call(this);
	};
	_proto.declareData = function declareData() {
		var _Container$prototype$;
		var selection = this.selection.configureWidget(this);
		(_Container$prototype$ = _Container.prototype.declareData).call.apply(
			_Container$prototype$,
			[this].concat(Array.prototype.slice.call(arguments), [
				selection,
				{
					selected: undefined,
					shape: undefined,
					colorIndex: undefined,
					colorMap: undefined,
					colorName: undefined,
					name: undefined,
					active: true,
					size: undefined,
					rx: undefined,
					ry: undefined,
					text: undefined,
				},
			]),
		);
	};
	_proto.prepareData = function prepareData(context, instance) {
		var data = instance.data;
		if (data.name && !data.colorName) data.colorName = data.name;
		_Container.prototype.prepareData.call(this, context, instance);
	};
	_proto.explore = function explore(context, instance) {
		var data = instance.data;
		instance.colorMap = data.colorMap && context.getColorMap && context.getColorMap(data.colorMap);
		if (instance.colorMap && data.colorName) instance.colorMap.acknowledge(data.colorName);
		_Container.prototype.explore.call(this, context, instance);
	};
	_proto.prepare = function prepare(context, instance) {
		var data = instance.data,
			colorMap = instance.colorMap;
		if (colorMap && data.colorName) {
			data.colorIndex = colorMap.map(data.colorName);
			if (instance.cache("colorIndex", data.colorIndex)) instance.markShouldUpdate(context);
		}
	};
	_proto.handleClick = function handleClick(e, instance) {
		if (this.onClick && instance.invoke("onClick", e, instance) === false) return;
		e.stopPropagation();
		var any = this.legendAction == "auto";
		if (any || this.legendAction == "toggle") if (instance.set("active", !instance.data.active)) return;
		if ((any || this.legendAction == "select") && !this.selection.isDummy) this.selection.selectInstance(instance);
	};
	_proto.render = function render(context, instance, key) {
		var _this = this;
		var data = instance.data;
		var content = !isUndefined(this.text) ? data.text : this.renderChildren(context, instance);
		return /*#__PURE__*/ jsxs(
			"div",
			{
				className: data.classNames,
				style: data.style,
				onMouseDown: stopPropagation,
				onClick: function onClick(e) {
					_this.handleClick(e, instance);
				},
				children: [
					this.renderShape(instance),
					content != null &&
						/*#__PURE__*/ jsx("div", {
							children: content,
						}),
				],
			},
			key,
		);
	};
	_proto.renderShape = function renderShape(instance) {
		var _this$CSS$element, _style$fill, _style$stroke;
		var entry = instance.data;
		var className = this.CSS.element(
			this.baseClass,
			"shape",
			((_this$CSS$element = {
				disabled: entry.disabled,
				selected: entry.selected || this.selection.isInstanceSelected(instance),
			}),
			(_this$CSS$element["color-" + entry.colorIndex] =
				entry.colorIndex != null && (isUndefined(entry.active) || entry.active)),
			_this$CSS$element),
		);
		var shape = getShape(entry.shape || "square");

		// if the entry has a custom fill or stroke set, use it for both values
		var style = _extends({}, entry.style);
		style.fill = (_style$fill = style.fill) != null ? _style$fill : style.stroke;
		style.stroke = (_style$stroke = style.stroke) != null ? _style$stroke : style.fill;
		return /*#__PURE__*/ jsx(
			"svg",
			{
				className: this.CSS.element(this.baseClass, "svg"),
				style: {
					width: this.svgSize + "px",
					height: this.svgSize + "px",
				},
				children: shape(this.svgSize / 2, this.svgSize / 2, entry.size, {
					style: style,
					className: className,
					rx: entry.rx,
					ry: entry.ry,
				}),
			},
			"svg",
		);
	};
	return LegendEntry;
})(Container);
LegendEntry.prototype.baseClass = "legendentry";
LegendEntry.prototype.shape = "square";
LegendEntry.prototype.legendAction = "auto";
LegendEntry.prototype.size = 18;
LegendEntry.prototype.svgSize = 20;
LegendEntry.prototype.styled = true;
Widget.alias("legend-entry", LegendEntry);

var ColorMap = /*#__PURE__*/ (function (_Widget) {
	function ColorMap() {
		return _Widget.apply(this, arguments) || this;
	}
	_inheritsLoose(ColorMap, _Widget);
	var _proto = ColorMap.prototype;
	_proto.declareData = function declareData() {
		var _Widget$prototype$dec;
		(_Widget$prototype$dec = _Widget.prototype.declareData).call.apply(
			_Widget$prototype$dec,
			[this].concat(Array.prototype.slice.call(arguments), [
				{
					names: undefined,
					offset: undefined,
					step: undefined,
					size: undefined,
				},
			]),
		);
	};
	_proto.explore = function explore(context, instance) {
		var _this = this;
		if (!context.colorMaps) context.colorMaps = {};
		context.getColorMap = function (colorMap) {
			var map = context.colorMaps[colorMap];
			if (!map) {
				var cache = _this.onGetCache ? instance.invoke("onGetCache") : {};
				map = cache[colorMap];
				if (!map) {
					var data = instance.data;
					map =
						context.colorMaps[colorMap] =
						cache[colorMap] =
							new ColorIndex({
								offset: data.offset,
								step: data.step,
								size: data.size,
							});
				}
				if (Array.isArray(instance.data.names))
					instance.data.names.forEach(function (name) {
						return map.acknowledge(name);
					});
			}
			return map;
		};
	};
	_proto.render = function render() {
		return null;
	};
	return ColorMap;
})(Widget);
ColorMap.prototype.offset = 0;
ColorMap.prototype.step = null;
ColorMap.prototype.size = 16;
var ColorMapScope = /*#__PURE__*/ (function (_PureContainer) {
	function ColorMapScope() {
		return _PureContainer.apply(this, arguments) || this;
	}
	_inheritsLoose(ColorMapScope, _PureContainer);
	var _proto2 = ColorMapScope.prototype;
	_proto2.explore = function explore(context, instance) {
		context.push("colorMaps", (instance.colorMaps = {}));
		_PureContainer.prototype.explore.call(this, context, instance);
	};
	_proto2.exploreCleanup = function exploreCleanup(context, instance) {
		context.pop("colorMaps");
	};
	_proto2.prepare = function prepare(context, instance) {
		context.push("colorMaps", instance.colorMaps);
	};
	_proto2.prepareCleanup = function prepareCleanup(context, instance) {
		context.pop("colorMaps");
	};
	return ColorMapScope;
})(PureContainer);
ColorMap.Scope = ColorMapScope;
Widget.alias("color-map", ColorMap);
var ColorIndex = /*#__PURE__*/ (function () {
	function ColorIndex(_ref) {
		var offset = _ref.offset,
			step = _ref.step,
			size = _ref.size;
		this.colorMap = {};
		this.dirty = true;
		this.offset = offset;
		this.step = step;
		this.size = size;
	}
	var _proto3 = ColorIndex.prototype;
	_proto3.acknowledge = function acknowledge(name) {
		if (!(name in this.colorMap)) {
			this.colorMap[name] = Object.keys(this.colorMap).length;
			this.dirty = true;
		}
	};
	_proto3.map = function map(name) {
		if (this.dirty) {
			this.dirty = false;
			if (!this.step) {
				var n = Object.keys(this.colorMap).length;
				this.step = n > 0 ? this.size / n : 1;
			}
		}
		var index = this.colorMap[name] || 0;
		return Math.round(this.offset + this.step * index + this.size) % this.size;
	};
	return ColorIndex;
})();

var Marker = /*#__PURE__*/ (function (_BoundedObject) {
	function Marker() {
		return _BoundedObject.apply(this, arguments) || this;
	}
	_inheritsLoose(Marker, _BoundedObject);
	var _proto = Marker.prototype;
	_proto.init = function init() {
		this.selection = Selection.create(this.selection);
		if (this.draggable) {
			this.draggableX = true;
			this.draggableY = true;
		}
		if (this.constrain) {
			this.constrainX = true;
			this.constrainY = true;
		}
		_BoundedObject.prototype.init.call(this);
	};
	_proto.declareData = function declareData() {
		var _BoundedObject$protot;
		var selection = this.selection.configureWidget(this);
		return (_BoundedObject$protot = _BoundedObject.prototype.declareData).call.apply(
			_BoundedObject$protot,
			[this].concat(Array.prototype.slice.call(arguments), [
				selection,
				{
					x: undefined,
					y: undefined,
					size: undefined,
					shape: undefined,
					disabled: undefined,
					colorMap: undefined,
					colorIndex: undefined,
					colorName: undefined,
					legendColorIndex: undefined,
					name: undefined,
					active: true,
					stack: undefined,
					stackedX: undefined,
					stackedY: undefined,
					rx: undefined,
					ry: undefined,
				},
			]),
		);
	};
	_proto.prepareData = function prepareData(context, instance) {
		instance.axes = context.axes;
		instance.xAxis = context.axes[this.xAxis];
		instance.yAxis = context.axes[this.yAxis];
		var data = instance.data;
		data.selected = this.selection.isInstanceSelected(instance);
		data.stateMods = {
			selected: data.selected,
			disabled: data.disabled,
			selectable: !this.selection.isDummy,
			"draggable-x": this.draggableX && !this.draggableY,
			"draggable-y": this.draggableY && !this.draggableX,
			"draggable-xy": this.draggableY && this.draggableX,
		};
		if (data.name && !data.colorName) data.colorName = data.name;
		_BoundedObject.prototype.prepareData.call(this, context, instance);
	};
	_proto.calculateBounds = function calculateBounds(context, instance) {
		var data = instance.data,
			xAxis = instance.xAxis,
			yAxis = instance.yAxis;
		var x, y;
		if (data.x == null || data.y == null) {
			var bounds = _BoundedObject.prototype.calculateBounds.call(this, context, instance);
			x = (bounds.l + bounds.r) / 2;
			y = (bounds.t + bounds.b) / 2;
		}
		if (data.x != null) x = data.stackedX ? xAxis.stack(data.stack, data.y, data.x) : xAxis.map(data.x);
		if (data.y != null) y = data.stackedY ? yAxis.stack(data.stack, data.x, data.y) : yAxis.map(data.y);
		return new Rect({
			l: x - data.size / 2,
			r: x + data.size / 2,
			t: y - data.size / 2,
			b: y + data.size / 2,
		});
	};
	_proto.explore = function explore(context, instance) {
		var data = instance.data,
			xAxis = instance.xAxis,
			yAxis = instance.yAxis;
		instance.colorMap = data.colorMap && context.getColorMap && context.getColorMap(data.colorMap);
		if (instance.colorMap && data.colorName) instance.colorMap.acknowledge(data.colorName);
		if (data.active) {
			if (this.affectsAxes) {
				if (xAxis && data.x != null) {
					if (data.stackedX) xAxis.stacknowledge(data.stack, data.y, data.x);
					else xAxis.acknowledge(data.x, 0, this.xOffset);
				}
				if (yAxis && data.y != null) {
					if (data.stackedY) yAxis.stacknowledge(data.stack, data.x, data.y);
					else yAxis.acknowledge(data.y, 0, this.yOffset);
				}
			}
			_BoundedObject.prototype.explore.call(this, context, instance);
		}
	};
	_proto.prepare = function prepare(context, instance) {
		var _this = this;
		var data = instance.data,
			xAxis = instance.xAxis,
			yAxis = instance.yAxis,
			colorMap = instance.colorMap;
		if (colorMap && data.colorName) {
			data.colorIndex = colorMap.map(data.colorName);
			if (instance.cache("colorIndex", data.colorIndex)) instance.markShouldUpdate(context);
		}
		if (data.active) {
			if (xAxis && xAxis.shouldUpdate) instance.markShouldUpdate(context);
			if (yAxis && yAxis.shouldUpdate) instance.markShouldUpdate(context);
			if (context.pointReducer) context.pointReducer(data.x, data.y, data.name, data);
		}
		_BoundedObject.prototype.prepare.call(this, context, instance);
		if (data.name && context.addLegendEntry)
			context.addLegendEntry(this.legend, {
				name: data.name,
				active: data.active,
				colorIndex: data.legendColorIndex || data.colorIndex,
				disabled: data.disabled,
				selected: data.selected,
				style: data.style,
				shape: data.shape,
				onClick: function onClick(e) {
					_this.onLegendClick(e, instance);
				},
			});
	};
	_proto.onLegendClick = function onLegendClick(e, instance) {
		var allActions = this.legendAction == "auto";
		var data = instance.data;
		if (allActions || this.legendAction == "toggle") if (instance.set("active", !data.active)) return;
		if (allActions || this.legendAction == "select") this.handleClick(e, instance);
	};
	_proto.render = function render(context, instance, key) {
		var data = instance.data;
		if (!data.active || data.x === null || data.y === null) return null;
		return /*#__PURE__*/ jsx(
			MarkerComponent,
			{
				instance: instance,
				data: instance.data,
				shouldUpdate: instance.shouldUpdate,
				children: this.renderChildren(context, instance),
			},
			key,
		);
	};
	_proto.handleMouseDown = function handleMouseDown(e, instance) {
		var _this2 = this;
		if (this.draggableX || this.draggableY) {
			var svgEl = closest(e.target, function (el) {
				return el.tagName == "svg";
			});
			if (svgEl)
				captureMouseOrTouch(
					e,
					function (e, captureData) {
						_this2.handleDragMove(e, instance, captureData);
					},
					null,
					{
						svgEl: svgEl,
						el: e.target,
					},
					e.target.style.cursor,
				);
		} else {
			if (!this.selection.isDummy) this.selection.selectInstance(instance);
		}
	};
	_proto.handleClick = function handleClick(e, instance) {
		if (this.onClick) instance.invoke("onClick", e, instance);
	};
	_proto.handleDragMove = function handleDragMove(e, instance, captureData) {
		var cursor = getCursorPos(e);
		var svgBounds = getTopLevelBoundingClientRect(captureData.svgEl);
		var xAxis = instance.xAxis,
			yAxis = instance.yAxis;
		if (this.draggableX && xAxis) {
			var x = xAxis.trackValue(cursor.clientX - svgBounds.left, this.xOffset);
			if (this.constrainX) x = xAxis.constrainValue(x);
			instance.set("x", xAxis.encodeValue(x));
		}
		if (this.draggableY && yAxis) {
			var y = yAxis.trackValue(cursor.clientY - svgBounds.top, this.yOffset);
			if (this.constrainY) y = yAxis.constrainValue(y);
			instance.set("y", yAxis.encodeValue(y));
		}
		tooltipMouseMove(e, instance, this.tooltip, {
			target: captureData.el,
		});
	};
	return Marker;
})(BoundedObject);
Marker.prototype.xOffset = 0;
Marker.prototype.yOffset = 0;
Marker.prototype.size = 5;
Marker.prototype.anchors = "0.5 0.5 0.5 0.5";
Marker.prototype.xAxis = "x";
Marker.prototype.yAxis = "y";
Marker.prototype.baseClass = "marker";
Marker.prototype.draggableX = false;
Marker.prototype.draggableY = false;
Marker.prototype.draggable = false;
Marker.prototype.constrainX = false;
Marker.prototype.constrainY = false;
Marker.prototype.constrain = false;
Marker.prototype.legend = "legend";
Marker.prototype.legendAction = "auto";
Marker.prototype.shape = "circle";
Marker.prototype.styled = true;
Marker.prototype.hidden = false;
Marker.prototype.affectsAxes = true;
Marker.prototype.stackedY = false;
Marker.prototype.stackedX = false;
Marker.prototype.stack = "stack";
BoundedObject.alias("marker", Marker);
var MarkerComponent = /*#__PURE__*/ (function (_VDOM$Component) {
	function MarkerComponent() {
		return _VDOM$Component.apply(this, arguments) || this;
	}
	_inheritsLoose(MarkerComponent, _VDOM$Component);
	var _proto2 = MarkerComponent.prototype;
	_proto2.shouldComponentUpdate = function shouldComponentUpdate(props) {
		return props.shouldUpdate;
	};
	_proto2.render = function render() {
		var _CSS$element,
			_this3 = this;
		var _this$props = this.props,
			instance = _this$props.instance,
			children = _this$props.children,
			data = _this$props.data;
		var widget = instance.widget;
		var CSS = widget.CSS,
			baseClass = widget.baseClass;
		var bounds = data.bounds,
			shape = data.shape;
		var shapeRenderer = getShape(shape);
		var shapeProps = {
			className: CSS.element(
				baseClass,
				"shape",
				((_CSS$element = {}),
				(_CSS$element["color-" + data.colorIndex] = data.colorIndex != null),
				(_CSS$element.selected = data.selected),
				_CSS$element),
			),
			style: data.style,
			cx: (bounds.l + bounds.r) / 2,
			cy: (bounds.t + bounds.b) / 2,
			r: data.size / 2,
			onMouseMove: function onMouseMove(e) {
				tooltipMouseMove(e, instance, widget.tooltip);
			},
			onMouseLeave: function onMouseLeave(e) {
				tooltipMouseLeave(e, instance, widget.tooltip);
			},
			onMouseDown: function onMouseDown(e) {
				widget.handleMouseDown(e, instance);
			},
			onTouchStart: function onTouchStart(e) {
				widget.handleMouseDown(e, instance);
			},
			onClick: function onClick(e) {
				widget.handleClick(e, instance);
			},
		};
		if (shape == "rect" || shape == "square" || shape == "bar" || shape == "column") {
			shapeProps.rx = data.rx;
			shapeProps.ry = data.ry;
		}
		if (widget.tooltip) {
			shapeProps.ref = function (c) {
				_this3.el = c;
			};
		}
		return /*#__PURE__*/ jsxs("g", {
			className: data.classNames,
			children: [
				!widget.hidden && shapeRenderer((bounds.l + bounds.r) / 2, (bounds.t + bounds.b) / 2, data.size, shapeProps),
				children,
			],
		});
	};
	_proto2.componentWillUnmount = function componentWillUnmount() {
		tooltipParentWillUnmount(this.props.instance);
	};
	_proto2.UNSAFE_componentWillReceiveProps = function UNSAFE_componentWillReceiveProps(props) {
		tooltipParentWillReceiveProps(this.el, props.instance, props.instance.widget.tooltip);
	};
	_proto2.componentDidMount = function componentDidMount() {
		tooltipParentDidMount(this.el, this.props.instance, this.props.instance.widget.tooltip);
	};
	_proto2.componentDidUpdate = function componentDidUpdate() {
		tooltipParentDidUpdate(this.el, this.props.instance, this.props.instance.widget.tooltip);
	};
	return MarkerComponent;
})(VDOM.Component);

var MarkerLine = /*#__PURE__*/ (function (_BoundedObject) {
	function MarkerLine() {
		return _BoundedObject.apply(this, arguments) || this;
	}
	_inheritsLoose(MarkerLine, _BoundedObject);
	var _proto = MarkerLine.prototype;
	_proto.init = function init() {
		if (isDefined(this.x)) this.x1 = this.x2 = this.x;
		if (isDefined(this.y)) this.y1 = this.y2 = this.y;
		_BoundedObject.prototype.init.call(this);
	};
	_proto.declareData = function declareData() {
		var _BoundedObject$protot;
		(_BoundedObject$protot = _BoundedObject.prototype.declareData).call.apply(
			_BoundedObject$protot,
			[this].concat(Array.prototype.slice.call(arguments), [
				{
					x1: undefined,
					y1: undefined,
					x2: undefined,
					y2: undefined,
					colorIndex: undefined,
					active: true,
					name: undefined,
					legend: undefined,
				},
			]),
		);
	};
	_proto.explore = function explore(context, instance) {
		var data = instance.data;
		var xAxis = (instance.xAxis = context.axes[this.xAxis]);
		var yAxis = (instance.yAxis = context.axes[this.yAxis]);
		if (data.active) {
			if (this.affectsAxes) {
				if (data.x1 != null) xAxis.acknowledge(data.x1);
				if (data.x2 != null) xAxis.acknowledge(data.x2);
				if (data.y1 != null) yAxis.acknowledge(data.y1);
				if (data.y2 != null) yAxis.acknowledge(data.y2);
			}
			_BoundedObject.prototype.explore.call(this, context, instance);
		}
	};
	_proto.prepare = function prepare(context, instance) {
		var _this = this;
		var data = instance.data,
			xAxis = instance.xAxis,
			yAxis = instance.yAxis;
		if ((xAxis && xAxis.shouldUpdate) || (yAxis && yAxis.shouldUpdate)) instance.markShouldUpdate(context);
		_BoundedObject.prototype.prepare.call(this, context, instance);
		if (data.name && data.legend && context.addLegendEntry)
			context.addLegendEntry(data.legend, {
				name: data.name,
				active: data.active,
				colorIndex: data.colorIndex,
				style: data.style,
				shape: "line",
				onClick: function onClick(e) {
					_this.onLegendClick(e, instance);
				},
			});
	};
	_proto.calculateBounds = function calculateBounds(context, instance) {
		var data = instance.data,
			xAxis = instance.xAxis,
			yAxis = instance.yAxis;
		var bounds = _BoundedObject.prototype.calculateBounds.call(this, context, instance);
		var x1 = bounds.l,
			x2 = bounds.r,
			y1 = bounds.t,
			y2 = bounds.b;
		if (data.x1 != null) x1 = xAxis.map(data.x1);
		if (data.x2 != null) x2 = xAxis.map(data.x2);
		if (data.y1 != null) y1 = yAxis.map(data.y1);
		if (data.y2 != null) y2 = yAxis.map(data.y2);
		bounds.l = Math.min(x1, x2);
		bounds.t = Math.min(y1, y2);
		bounds.r = Math.max(x1, x2);
		bounds.b = Math.max(y1, y2);
		instance.x1 = x1;
		instance.x2 = x2;
		instance.y1 = y1;
		instance.y2 = y2;
		return bounds;
	};
	_proto.render = function render(context, instance, key) {
		var _stateMods;
		var data = instance.data,
			x1 = instance.x1,
			x2 = instance.x2,
			y1 = instance.y1,
			y2 = instance.y2;
		if (!data.active || data.x1 === null || data.x2 === null || data.y1 === null || data.y2 === null) return null;
		var stateMods = ((_stateMods = {}), (_stateMods["color-" + data.colorIndex] = data.colorIndex != null), _stateMods);
		return /*#__PURE__*/ jsxs(
			"g",
			{
				className: data.classNames,
				children: [
					/*#__PURE__*/ jsx("line", {
						className: this.CSS.element(this.baseClass, "line", stateMods),
						style: data.style,
						x1: x1,
						y1: y1,
						x2: x2,
						y2: y2,
					}),
					this.renderChildren(context, instance),
				],
			},
			key,
		);
	};
	return MarkerLine;
})(BoundedObject);
MarkerLine.prototype.xAxis = "x";
MarkerLine.prototype.yAxis = "y";
MarkerLine.prototype.anchors = "0 1 1 0";
MarkerLine.prototype.baseClass = "markerline";
MarkerLine.prototype.legend = "legend";
MarkerLine.prototype.legendAction = "auto";
MarkerLine.prototype.affectsAxes = true;
BoundedObject.alias("marker-line", MarkerLine);

var Range = /*#__PURE__*/ (function (_BoundedObject) {
	function Range() {
		return _BoundedObject.apply(this, arguments) || this;
	}
	_inheritsLoose(Range, _BoundedObject);
	var _proto = Range.prototype;
	_proto.declareData = function declareData() {
		var _BoundedObject$protot;
		(_BoundedObject$protot = _BoundedObject.prototype.declareData).call.apply(
			_BoundedObject$protot,
			[this].concat(Array.prototype.slice.call(arguments), [
				{
					x1: undefined,
					y1: undefined,
					x2: undefined,
					y2: undefined,
					colorIndex: undefined,
					active: true,
					name: undefined,
					legend: undefined,
				},
			]),
		);
	};
	_proto.explore = function explore(context, instance) {
		var data = instance.data;
		var xAxis = (instance.xAxis = context.axes[this.xAxis]);
		var yAxis = (instance.yAxis = context.axes[this.yAxis]);
		if (data.active) {
			if (xAxis) {
				if (data.x1 != null) instance.xAxis.acknowledge(data.x1, this.xSize, this.xOffset);
				if (data.x2 != null) instance.xAxis.acknowledge(data.x2, this.xSize, this.xOffset);
			}
			if (yAxis) {
				if (data.y1 != null) instance.yAxis.acknowledge(data.y1, this.ySize, this.yOffset);
				if (data.y2 != null) instance.yAxis.acknowledge(data.y2, this.ySize, this.yOffset);
			}
			_BoundedObject.prototype.explore.call(this, context, instance);
		}
	};
	_proto.prepare = function prepare(context, instance) {
		var _this = this;
		_BoundedObject.prototype.prepare.call(this, context, instance);
		var data = instance.data,
			xAxis = instance.xAxis,
			yAxis = instance.yAxis;
		if (xAxis && xAxis.shouldUpdate) instance.markShouldUpdate(context);
		if (yAxis && yAxis.shouldUpdate) instance.markShouldUpdate(context);
		if (data.name && data.legend && context.addLegendEntry)
			context.addLegendEntry(data.legend, {
				name: data.name,
				active: data.active,
				colorIndex: data.colorIndex,
				style: data.style,
				shape: "rect",
				onClick: function onClick(e) {
					_this.onLegendClick(e, instance);
				},
			});
	};
	_proto.onLegendClick = function onLegendClick(e, instance) {
		var allActions = this.legendAction == "auto";
		var data = instance.data;
		if (allActions || this.legendAction == "toggle") instance.set("active", !data.active);
	};
	_proto.calculateBounds = function calculateBounds(context, instance) {
		var bounds = _BoundedObject.prototype.calculateBounds.call(this, context, instance);
		var data = instance.data,
			xAxis = instance.xAxis,
			yAxis = instance.yAxis;
		if (data.x1 != null) bounds.l = xAxis.map(data.x1, this.xOffset - this.xSize / 2);
		if (data.x2 != null) bounds.r = xAxis.map(data.x2, this.xOffset + this.xSize / 2);
		if (data.y1 != null) bounds.t = yAxis.map(data.y1, this.yOffset - this.ySize / 2);
		if (data.y2 != null) bounds.b = yAxis.map(data.y2, this.yOffset + this.ySize / 2);
		return bounds;
	};
	_proto.render = function render(context, instance, key) {
		var _stateMods,
			_this2 = this;
		var data = instance.data;
		if (!data.active) return null;
		var bounds = data.bounds;
		var x1 = Math.min(bounds.l, bounds.r),
			y1 = Math.min(bounds.t, bounds.b),
			x2 = Math.max(bounds.l, bounds.r),
			y2 = Math.max(bounds.t, bounds.b);
		var stateMods = ((_stateMods = {}), (_stateMods["color-" + data.colorIndex] = data.colorIndex != null), _stateMods);
		return /*#__PURE__*/ jsxs(
			"g",
			{
				className: data.classNames,
				children: [
					!this.hidden &&
						/*#__PURE__*/ jsx("rect", {
							className: this.CSS.element(this.baseClass, "rect", stateMods),
							style: data.style,
							x: x1,
							y: y1,
							width: x2 - x1,
							height: y2 - y1,
							onMouseDown: function onMouseDown(e) {
								return _this2.handleMouseDown(e, instance);
							},
							onTouchStart: function onTouchStart(e) {
								return _this2.handleMouseDown(e, instance);
							},
						}),
					this.renderChildren(context, instance),
				],
			},
			key,
		);
	};
	_proto.handleClick = function handleClick(e, instance) {
		if (this.onClick) instance.invoke("onClick", e, instance);
	};
	_proto.handleMouseDown = function handleMouseDown(e, instance) {
		var _this3 = this;
		if (this.draggableX || this.draggableY) {
			var svgEl = closest(e.target, function (el) {
				return el.tagName == "svg";
			});
			var svgBounds = getTopLevelBoundingClientRect(svgEl);
			var cursor = getCursorPos(e);
			var data = instance.data,
				xAxis = instance.xAxis,
				yAxis = instance.yAxis;
			var captureData = {
				svgBounds: svgBounds,
				start: {
					x1: data.x1,
					x2: data.x2,
					y1: data.y1,
					y2: data.y2,
				},
			};
			if (this.draggableX && xAxis)
				captureData.start.x = xAxis.trackValue(cursor.clientX - svgBounds.left, this.xOffset, this.constrainX);
			if (this.draggableY && yAxis)
				captureData.start.y = yAxis.trackValue(cursor.clientY - svgBounds.top, this.yOffset, this.constrainY);
			if (svgEl)
				captureMouseOrTouch(
					e,
					function (e, captureData) {
						_this3.handleDragMove(e, instance, captureData);
					},
					null,
					captureData,
					e.target.style.cursor,
				);
		}
	};
	_proto.handleDragMove = function handleDragMove(e, instance, captureData) {
		var cursor = getCursorPos(e);
		var xAxis = instance.xAxis,
			yAxis = instance.yAxis;
		var svgBounds = captureData.svgBounds;
		captureData.start;
		if (this.draggableX && xAxis) {
			var dist = xAxis.trackValue(cursor.clientX - svgBounds.left, this.xOffset, this.constrainX) - captureData.start.x;
			var x1v = xAxis.decodeValue(captureData.start.x1);
			var x2v = xAxis.decodeValue(captureData.start.x2);
			if (this.constrainX) {
				if (dist > 0) dist = Math.min(xAxis.constrainValue(x2v + dist) - x2v, dist);
				else dist = Math.max(xAxis.constrainValue(x1v + dist) - x1v, dist);
			}
			instance.set("x1", xAxis.encodeValue(x1v + dist));
			instance.set("x2", xAxis.encodeValue(x2v + dist));
		}
		if (this.draggableY && yAxis) {
			var dist = yAxis.trackValue(cursor.clientY - svgBounds.left, this.yOffset, this.constrainY) - captureData.start.y;
			var y1v = yAxis.decodeValue(captureData.start.y1);
			var y2v = yAxis.decodeValue(captureData.start.y2);
			if (this.constrainY)
				dist = Math.max(yAxis.constrainValue(y1v + dist) - y1v, Math.min(yAxis.constrainValue(y2v + dist) - y2v, dist));
			instance.set("y1", yAxis.encodeValue(y1v + dist));
			instance.set("y2", yAxis.encodeValue(y2v + dist));
		}
	};
	return Range;
})(BoundedObject);
Range.prototype.invisible = false;
Range.prototype.xAxis = "x";
Range.prototype.yAxis = "y";
Range.prototype.xSize = 0;
Range.prototype.ySize = 0;
Range.prototype.xOffset = 0;
Range.prototype.yOffset = 0;
Range.prototype.anchors = "0 1 1 0";
Range.prototype.baseClass = "range";
Range.prototype.legend = "legend";
Range.prototype.legendAction = "auto";
BoundedObject.alias("range", Range);

var Gridlines = /*#__PURE__*/ (function (_BoundedObject) {
	function Gridlines() {
		return _BoundedObject.apply(this, arguments) || this;
	}
	_inheritsLoose(Gridlines, _BoundedObject);
	var _proto = Gridlines.prototype;
	_proto.explore = function explore(context, instance) {
		_BoundedObject.prototype.explore.call(this, context, instance);
		instance.xAxis = context.axes[this.xAxis];
		instance.yAxis = context.axes[this.yAxis];
	};
	_proto.prepare = function prepare(context, instance) {
		_BoundedObject.prototype.prepare.call(this, context, instance);
		var xAxis = instance.xAxis,
			yAxis = instance.yAxis;
		if ((xAxis && xAxis.shouldUpdate) || (yAxis && yAxis.shouldUpdate)) instance.markShouldUpdate(context);
	};
	_proto.render = function render(context, instance, key) {
		var data = instance.data,
			xAxis = instance.xAxis,
			yAxis = instance.yAxis;
		var bounds = data.bounds;
		var path = "",
			xTicks,
			yTicks;
		if (xAxis) {
			xTicks = xAxis.mapGridlines();
			xTicks.forEach(function (x) {
				path += "M " + x + " " + bounds.t + " L " + x + " " + bounds.b;
			});
		}
		if (yAxis) {
			yTicks = yAxis.mapGridlines();
			yTicks.forEach(function (y) {
				path += "M " + bounds.l + " " + y + " L " + bounds.r + " " + y;
			});
		}
		return /*#__PURE__*/ jsx(
			"g",
			{
				className: data.classNames,
				children: /*#__PURE__*/ jsx("path", {
					style: data.style,
					d: path,
				}),
			},
			key,
		);
	};
	return Gridlines;
})(BoundedObject);
Gridlines.prototype.xAxis = "x";
Gridlines.prototype.yAxis = "y";
Gridlines.prototype.anchors = "0 1 1 0";
Gridlines.prototype.baseClass = "gridlines";
BoundedObject.alias("gridlines", Gridlines);

var Swimlanes = /*#__PURE__*/ (function (_BoundedObject) {
	function Swimlanes() {
		return _BoundedObject.apply(this, arguments) || this;
	}
	_inheritsLoose(Swimlanes, _BoundedObject);
	var _proto = Swimlanes.prototype;
	_proto.init = function init() {
		this.laneStyle = parseStyle(this.laneStyle);
		_BoundedObject.prototype.init.call(this);
	};
	_proto.declareData = function declareData() {
		var _BoundedObject$protot;
		for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
			args[_key] = arguments[_key];
		}
		(_BoundedObject$protot = _BoundedObject.prototype.declareData).call.apply(
			_BoundedObject$protot,
			[this].concat(args, [
				{
					size: undefined,
					step: undefined,
					laneOffset: undefined,
					laneStyle: {
						structured: true,
					},
				},
			]),
		);
	};
	_proto.explore = function explore(context, instance) {
		_BoundedObject.prototype.explore.call(this, context, instance);
		instance.xAxis = context.axes[this.xAxis];
		instance.yAxis = context.axes[this.yAxis];
	};
	_proto.prepare = function prepare(context, instance) {
		_BoundedObject.prototype.prepare.call(this, context, instance);
		var xAxis = instance.xAxis,
			yAxis = instance.yAxis;
		if ((xAxis && xAxis.shouldUpdate) || (yAxis && yAxis.shouldUpdate)) instance.markShouldUpdate(context);
	};
	_proto.render = function render(context, instance, key) {
		var data = instance.data,
			xAxis = instance.xAxis,
			yAxis = instance.yAxis;
		var bounds = data.bounds;
		var CSS = this.CSS,
			baseClass = this.baseClass;
		if (data.step <= 0 || data.size <= 0) return;
		var axis = this.vertical ? xAxis : yAxis;
		if (!axis) return null;
		var min, max, valueFunction;
		if (axis.scale) {
			min = axis.scale.min;
			max = axis.scale.max;
			var clamp = function clamp(value) {
				return [Math.max(min, Math.min(max, value)), 0];
			};
			valueFunction = function valueFunction(value, offset) {
				return clamp(value + offset);
			};
		} else if (axis.valueList) {
			min = 0;
			max = axis.valueList.length;
			valueFunction = function valueFunction(value, offset) {
				return [axis.valueList[value], offset];
			};
		}
		if (!(min < max)) return null;
		var rects = [];
		var at = Math.ceil(min / data.step) * data.step;
		var index = 0;
		var rectClass = CSS.element(baseClass, "lane");
		while (at - data.size / 2 < max) {
			var c1 = axis.map.apply(axis, valueFunction(at, -data.size / 2 + data.laneOffset));
			var c2 = axis.map.apply(axis, valueFunction(at, +data.size / 2 + data.laneOffset));
			if (this.vertical) {
				rects.push(
					/*#__PURE__*/ jsx(
						"rect",
						{
							y: bounds.t,
							x: Math.min(c1, c2),
							height: bounds.b - bounds.t,
							width: Math.abs(c1 - c2),
							className: rectClass,
							style: data.laneStyle,
						},
						index++,
					),
				);
			} else {
				rects.push(
					/*#__PURE__*/ jsx(
						"rect",
						{
							x: bounds.l,
							y: Math.min(c1, c2),
							width: bounds.r - bounds.l,
							height: Math.abs(c1 - c2),
							className: rectClass,
							style: data.laneStyle,
						},
						index++,
					),
				);
			}
			at += data.step;
		}
		return /*#__PURE__*/ jsx(
			"g",
			{
				className: data.classNames,
				children: rects,
			},
			key,
		);
	};
	return Swimlanes;
})(BoundedObject);
Swimlanes.prototype.xAxis = "x";
Swimlanes.prototype.yAxis = "y";
Swimlanes.prototype.anchors = "0 1 1 0";
Swimlanes.prototype.baseClass = "swimlanes";
Swimlanes.prototype.size = 0.5;
Swimlanes.prototype.laneOffset = 0;
Swimlanes.prototype.step = 1;
Swimlanes.prototype.vertical = false;
Swimlanes.prototype.styled = true;
BoundedObject.alias("swimlanes", Swimlanes);

var Swimlane = /*#__PURE__*/ (function (_BoundedObject) {
	function Swimlane() {
		return _BoundedObject.apply(this, arguments) || this;
	}
	_inheritsLoose(Swimlane, _BoundedObject);
	var _proto = Swimlane.prototype;
	_proto.init = function init() {
		this.laneStyle = parseStyle(this.laneStyle);
		_BoundedObject.prototype.init.call(this);
	};
	_proto.declareData = function declareData() {
		var _BoundedObject$protot;
		for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
			args[_key] = arguments[_key];
		}
		(_BoundedObject$protot = _BoundedObject.prototype.declareData).call.apply(
			_BoundedObject$protot,
			[this].concat(args, [
				{
					size: undefined,
					laneOffset: undefined,
					laneStyle: {
						structured: true,
					},
					vertical: undefined,
					x: undefined,
					y: undefined,
				},
			]),
		);
	};
	_proto.explore = function explore(context, instance) {
		var data = instance.data;
		_BoundedObject.prototype.explore.call(this, context, instance);
		instance.xAxis = context.axes[this.xAxis];
		instance.yAxis = context.axes[this.yAxis];
		if (data.vertical) {
			instance.xAxis.acknowledge(data.x, data.size, data.laneOffset);
		} else {
			instance.yAxis.acknowledge(data.y, data.size, data.laneOffset);
		}
	};
	_proto.prepare = function prepare(context, instance) {
		_BoundedObject.prototype.prepare.call(this, context, instance);
		instance.bounds = this.calculateRect(instance);
		instance.cache("bounds", instance.bounds);
		if (!instance.bounds.isEqual(instance.cached.bounds)) instance.markShouldUpdate(context);
		context.push("parentRect", instance.bounds);
	};
	_proto.calculateRect = function calculateRect(instance) {
		var data = instance.data;
		var size = data.size,
			laneOffset = data.laneOffset;
		if (data.vertical) {
			var x1 = instance.xAxis.map(data.x, laneOffset - size / 2);
			var x2 = instance.xAxis.map(data.x, laneOffset + size / 2);
			var bounds = new Rect({
				l: Math.min(x1, x2),
				r: Math.max(x1, x2),
				t: data.bounds.t,
				b: data.bounds.b,
			});
		} else {
			var y1 = instance.yAxis.map(data.y, laneOffset - size / 2);
			var y2 = instance.yAxis.map(data.y, laneOffset + size / 2);
			var bounds = new Rect({
				l: data.bounds.l,
				r: data.bounds.r,
				t: Math.min(y1, y2),
				b: Math.max(y1, y2),
			});
		}
		return bounds;
	};
	_proto.render = function render(context, instance, key) {
		var data = instance.data,
			xAxis = instance.xAxis,
			yAxis = instance.yAxis,
			bounds = instance.bounds;
		var CSS = this.CSS,
			baseClass = this.baseClass;
		var axis = this.vertical ? xAxis : yAxis;
		if (!axis) return null;
		var min, max, valueFunction;
		if (axis.scale) {
			min = axis.scale.min;
			max = axis.scale.max;
			var clamp = function clamp(value) {
				return [Math.max(min, Math.min(max, value)), 0];
			};
			valueFunction = function valueFunction(value, offset) {
				return clamp(value + offset);
			};
		} else if (axis.valueList) {
			min = 0;
			max = axis.valueList.length;
			valueFunction = function valueFunction(value, offset) {
				return [axis.valueList[value], offset];
			};
		}
		if (!(min < max)) return null;
		var rectClass = CSS.element(baseClass, "lane");
		if (this.vertical) {
			var c1 = axis.map.apply(axis, valueFunction(data.x, -data.size / 2 + data.laneOffset));
			var c2 = axis.map.apply(axis, valueFunction(data.x, +data.size / 2 + data.laneOffset));
			return /*#__PURE__*/ jsxs(
				"g",
				{
					className: data.classNames,
					children: [
						/*#__PURE__*/ jsx(
							"rect",
							{
								x: bounds.l,
								y: bounds.t,
								height: bounds.b - bounds.t,
								width: Math.abs(c1 - c2),
								className: rectClass,
								style: data.laneStyle,
							},
							key,
						),
						this.renderChildren(context, instance),
						";",
					],
				},
				key,
			);
		} else {
			var _c = axis.map.apply(axis, valueFunction(data.y, -data.size / 2 + data.laneOffset));
			var _c2 = axis.map.apply(axis, valueFunction(data.y, +data.size / 2 + data.laneOffset));
			return /*#__PURE__*/ jsxs(
				"g",
				{
					className: data.classNames,
					children: [
						/*#__PURE__*/ jsx(
							"rect",
							{
								x: bounds.l,
								y: bounds.t,
								width: bounds.r - bounds.l,
								height: Math.abs(_c - _c2),
								className: rectClass,
								style: data.laneStyle,
							},
							key,
						),
						this.renderChildren(context, instance),
						";",
					],
				},
				key,
			);
		}
	};
	return Swimlane;
})(BoundedObject);
Swimlane.prototype.xAxis = "x";
Swimlane.prototype.yAxis = "y";
Swimlane.prototype.anchors = "0 1 1 0";
Swimlane.prototype.baseClass = "swimlane";
Swimlane.prototype.size = 0.5;
Swimlane.prototype.laneOffset = 0;
Swimlane.prototype.vertical = false;
BoundedObject.alias("swimlane", Swimlane);

var RangeMarker = /*#__PURE__*/ (function (_BoundedObject) {
	function RangeMarker() {
		return _BoundedObject.apply(this, arguments) || this;
	}
	_inheritsLoose(RangeMarker, _BoundedObject);
	var _proto = RangeMarker.prototype;
	_proto.declareData = function declareData() {
		var _BoundedObject$protot;
		(_BoundedObject$protot = _BoundedObject.prototype.declareData).call.apply(
			_BoundedObject$protot,
			[this].concat(Array.prototype.slice.call(arguments), [
				{
					x: undefined,
					y: undefined,
					shape: undefined,
					vertical: undefined,
					size: undefined,
					laneOffset: undefined,
					lineStyle: {
						structured: true,
					},
					lineClass: {
						structured: true,
					},
					capSize: undefined,
					inflate: undefined,
				},
			]),
		);
	};
	_proto.init = function init() {
		this.lineStyle = parseStyle(this.lineStyle);
		_BoundedObject.prototype.init.call(this);
	};
	_proto.prepareData = function prepareData(context, instance) {
		instance.axes = context.axes;
		instance.xAxis = context.axes[this.xAxis];
		instance.yAxis = context.axes[this.yAxis];
		_BoundedObject.prototype.prepareData.call(this, context, instance);
	};
	_proto.explore = function explore(context, instance) {
		var data = instance.data,
			xAxis = instance.xAxis,
			yAxis = instance.yAxis;
		if (this.affectsAxes) {
			if (xAxis && data.x != null) xAxis.acknowledge(data.x, 0, 0);
			if (yAxis && data.y != null) yAxis.acknowledge(data.y, 0, 0);
		}
		_BoundedObject.prototype.explore.call(this, context, instance);
	};
	_proto.calculateBounds = function calculateBounds(context, instance) {
		var data = instance.data,
			xAxis = instance.xAxis,
			yAxis = instance.yAxis;
		var l, r, t, b;
		if (data.x == null || data.y == null) {
			return _BoundedObject.prototype.calculateBounds.call(this, context, instance);
		}
		if (!this.vertical) {
			l = xAxis.map(data.x, data.laneOffset - data.size / 2) - data.inflate;
			r = xAxis.map(data.x, data.laneOffset + data.size / 2) + data.inflate;
			t = b = yAxis.map(data.y);
			if (data.shape == "max") {
				b += data.capSize;
			} else if (data.shape == "min") {
				t -= data.capSize;
			}
		} else {
			l = r = xAxis.map(data.x);
			t = yAxis.map(data.y, data.laneOffset - data.size / 2) + data.inflate;
			b = yAxis.map(data.y, data.laneOffset + data.size / 2) - data.inflate;
			if (data.shape == "max") {
				l -= data.capSize;
			} else if (data.shape == "min") {
				r += data.capSize;
			}
		}
		return new Rect({
			l: l,
			r: r,
			t: t,
			b: b,
		});
	};
	_proto.prepare = function prepare(context, instance) {
		_BoundedObject.prototype.prepare.call(this, context, instance);
	};
	_proto.render = function render(context, instance, key) {
		var data = instance.data;
		var CSS = this.CSS,
			baseClass = this.baseClass;
		var bounds = data.bounds,
			shape = data.shape;
		var path = "";
		if (this.vertical) {
			switch (shape) {
				default:
				case "line":
					path += "M " + bounds.r + " " + bounds.t + " ";
					path += "L " + bounds.r + " " + bounds.b;
					break;
				case "max":
					path += "M " + bounds.l + " " + bounds.t + " ";
					path += "L " + bounds.r + " " + bounds.t;
					path += "L " + bounds.r + " " + bounds.b;
					path += "L " + bounds.l + " " + bounds.b;
					break;
				case "min":
					path += "M " + bounds.r + " " + bounds.t + " ";
					path += "L " + bounds.l + " " + bounds.t;
					path += "L " + bounds.l + " " + bounds.b;
					path += "L " + bounds.r + " " + bounds.b;
					break;
			}
		} else {
			switch (shape) {
				default:
				case "line":
					path += "M " + bounds.r + " " + bounds.t + " ";
					path += "L " + bounds.l + " " + bounds.t;
					break;
				case "max":
					path += "M " + bounds.l + " " + bounds.b + " ";
					path += "L " + bounds.l + " " + bounds.t;
					path += "L " + bounds.r + " " + bounds.t;
					path += "L " + bounds.r + " " + bounds.b;
					break;
				case "min":
					path += "M " + bounds.l + " " + bounds.t + " ";
					path += "L " + bounds.l + " " + bounds.b;
					path += "L " + bounds.r + " " + bounds.b;
					path += "L " + bounds.r + " " + bounds.t;
					break;
			}
		}
		return /*#__PURE__*/ jsxs(
			"g",
			{
				class: data.classNames,
				style: data.style,
				children: [
					/*#__PURE__*/ jsx("path", {
						d: path,
						class: CSS.expand(CSS.element(baseClass, "path"), data.lineClass),
						style: data.lineStyle,
					}),
					this.renderChildren(context, instance),
				],
			},
			key,
		);
	};
	return RangeMarker;
})(BoundedObject);
RangeMarker.prototype.baseClass = "rangemarker";
RangeMarker.prototype.xAxis = "x";
RangeMarker.prototype.yAxis = "y";
RangeMarker.prototype.shape = "line";
RangeMarker.prototype.vertical = false;
RangeMarker.prototype.size = 1;
RangeMarker.prototype.laneOffset = 0;
RangeMarker.prototype.capSize = 5;
RangeMarker.prototype.inflate = 0;
RangeMarker.prototype.affectsAxes = true;
Widget.alias("range-marker", RangeMarker);

var LineGraph = /*#__PURE__*/ (function (_Widget) {
	function LineGraph() {
		return _Widget.apply(this, arguments) || this;
	}
	_inheritsLoose(LineGraph, _Widget);
	var _proto = LineGraph.prototype;
	_proto.declareData = function declareData() {
		var _Widget$prototype$dec;
		(_Widget$prototype$dec = _Widget.prototype.declareData).call.apply(
			_Widget$prototype$dec,
			[this].concat(Array.prototype.slice.call(arguments), [
				{
					data: undefined,
					colorIndex: undefined,
					colorMap: undefined,
					class: {
						structured: true,
					},
					className: {
						structured: true,
					},
					lineStyle: {
						structured: true,
					},
					areaStyle: {
						structured: true,
					},
					area: undefined,
					line: undefined,
					y0: undefined,
					name: undefined,
					active: true,
					stack: undefined,
					stacked: undefined,
				},
			]),
		);
	};
	_proto.prepareData = function prepareData(context, instance) {
		var data = instance.data;
		if (data.name && !data.colorName) data.colorName = data.name;
		_Widget.prototype.prepareData.call(this, context, instance);
	};
	_proto.explore = function explore(context, instance) {
		var _this = this;
		var data = instance.data;
		instance.colorMap = data.colorMap && context.getColorMap && context.getColorMap(data.colorMap);
		if (instance.colorMap && data.colorName) instance.colorMap.acknowledge(data.colorName);
		if (data.active) {
			instance.axes = context.axes;
			instance.xAxis = instance.axes[this.xAxis];
			instance.yAxis = instance.axes[this.yAxis];
			_Widget.prototype.explore.call(this, context, instance);
			if (isArray(data.data)) {
				data.data.forEach(function (p, index) {
					var x = p[_this.xField];
					instance.xAxis.acknowledge(x);
					if (data.stacked) {
						instance.yAxis.stacknowledge(data.stack, x, _this.y0Field ? p[_this.y0Field] : data.y0);
						instance.yAxis.stacknowledge(data.stack, x, p[_this.yField]);
					} else {
						instance.yAxis.acknowledge(p[_this.yField]);
						if (data.area) {
							if (!_this.hiddenBase) instance.yAxis.acknowledge(_this.y0Field ? p[_this.y0Field] : data.y0);
						}
					}
				});
			}
		}
	};
	_proto.prepare = function prepare(context, instance) {
		var _this2 = this;
		var data = instance.data,
			colorMap = instance.colorMap;
		if (colorMap && data.colorName) {
			data.colorIndex = colorMap.map(data.colorName);
			if (instance.cache("colorIndex", data.colorIndex)) instance.markShouldUpdate(context);
		}
		if (data.active) {
			if (instance.axes[this.xAxis].shouldUpdate || instance.axes[this.yAxis].shouldUpdate)
				instance.markShouldUpdate(context);
		}
		if (data.name && context.addLegendEntry) {
			context.addLegendEntry(this.legend, {
				name: data.name,
				active: data.active,
				colorIndex: data.colorIndex,
				disabled: data.disabled,
				style: _extends({}, parseStyle(data.style), parseStyle(data.areaStyle), parseStyle(data.lineStyle)),
				shape: this.legendShape,
				onClick: function onClick(e) {
					_this2.onLegendClick(e, instance);
				},
			});
		}
		if (data.active) {
			if (context.pointReducer && isArray(data.data)) {
				data.data.forEach(function (p, index) {
					if (data.area && _this2.y0Field)
						context.pointReducer(p[_this2.xField], p[_this2.y0Field], data.name, p, data, index);
					context.pointReducer(p[_this2.xField], p[_this2.yField], data.name, p, data.data, index);
				});
			}
		}
		instance.lineSpans = this.calculateLineSpans(context, instance);
	};
	_proto.onLegendClick = function onLegendClick(e, instance) {
		var allActions = this.legendAction == "auto";
		var data = instance.data;
		if (allActions || this.legendAction == "toggle") instance.set("active", !data.active);
	};
	_proto.calculateLineSpans = function calculateLineSpans(context, instance) {
		var _this3 = this;
		var data = instance.data,
			xAxis = instance.xAxis,
			yAxis = instance.yAxis;
		var spans = [];
		var span = [];
		if (!data.active) return null;
		isArray(data.data) &&
			data.data.forEach(function (p) {
				var ax = p[_this3.xField],
					ay = p[_this3.yField],
					ay0 = _this3.y0Field ? p[_this3.y0Field] : data.y0,
					x,
					y,
					y0;
				if (ax != null && ay != null && ay0 != null) {
					x = xAxis.map(ax);
					y0 = data.stacked ? yAxis.stack(data.stack, ax, ay0) : yAxis.map(ay0);
					y = data.stacked ? yAxis.stack(data.stack, ax, ay) : yAxis.map(ay);
				}
				if (x != null && y != null && y0 != null)
					span.push({
						x: x,
						y: y,
						y0: y0,
					});
				else if (span.length > 0) {
					spans.push(span);
					span = [];
				}
			});
		if (span.length > 0) spans.push(span);
		return spans;
	};
	_proto.render = function render(context, instance, key) {
		var _stateMods;
		var data = instance.data,
			lineSpans = instance.lineSpans;
		if (!lineSpans) return null;
		var stateMods = ((_stateMods = {}), (_stateMods["color-" + data.colorIndex] = data.colorIndex != null), _stateMods);
		var line, area;
		if (data.line) {
			var linePath = "";
			lineSpans.forEach(function (span) {
				span.forEach(function (p, i) {
					linePath += i == 0 ? " M " : " L ";
					linePath += p.x + " " + p.y;
				});
			});
			line = /*#__PURE__*/ jsx("path", {
				className: this.CSS.element(this.baseClass, "line", stateMods),
				style: this.CSS.parseStyle(data.lineStyle),
				d: linePath,
			});
		}
		if (data.area) {
			var areaPath = "";
			lineSpans.forEach(function (span) {
				var closePath = "";
				span.forEach(function (p, i) {
					areaPath += i == 0 ? " M " : " L ";
					areaPath += p.x + " " + p.y;
					if (data.area) closePath = "L " + p.x + " " + p.y0 + " " + closePath;
				});
				areaPath += closePath;
				areaPath += "L " + span[0].x + " " + span[0].y;
			});
			area = /*#__PURE__*/ jsx("path", {
				className: this.CSS.element(this.baseClass, "area", stateMods),
				style: this.CSS.parseStyle(data.areaStyle),
				d: areaPath,
			});
		}
		return /*#__PURE__*/ jsxs(
			"g",
			{
				className: data.classNames,
				children: [line, area],
			},
			key,
		);
	};
	return LineGraph;
})(Widget);
LineGraph.prototype.xAxis = "x";
LineGraph.prototype.yAxis = "y";
LineGraph.prototype.area = false;
LineGraph.prototype.line = true;
LineGraph.prototype.xField = "x";
LineGraph.prototype.yField = "y";
LineGraph.prototype.baseClass = "linegraph";
LineGraph.prototype.y0 = 0;
LineGraph.prototype.y0Field = false;
LineGraph.prototype.active = true;
LineGraph.prototype.legend = "legend";
LineGraph.prototype.legendAction = "auto";
LineGraph.prototype.legendShape = "rect";
LineGraph.prototype.stack = "stack";
LineGraph.prototype.hiddenBase = false;
Widget.alias("line-graph", LineGraph);

var ColumnBarGraphBase = /*#__PURE__*/ (function (_Widget) {
	function ColumnBarGraphBase() {
		return _Widget.apply(this, arguments) || this;
	}
	_inheritsLoose(ColumnBarGraphBase, _Widget);
	var _proto = ColumnBarGraphBase.prototype;
	_proto.init = function init() {
		this.selection = Selection.create(this.selection, {
			records: this.data,
		});
		_Widget.prototype.init.call(this);
	};
	_proto.declareData = function declareData() {
		var _Widget$prototype$dec;
		var selection = this.selection.configureWidget(this);
		(_Widget$prototype$dec = _Widget.prototype.declareData).call.apply(
			_Widget$prototype$dec,
			[this, selection].concat(Array.prototype.slice.call(arguments), [
				{
					data: undefined,
					colorIndex: undefined,
					colorMap: undefined,
					colorName: undefined,
					name: undefined,
					size: undefined,
					offset: undefined,
					y0: undefined,
					x0: undefined,
					autoSize: undefined,
					active: true,
					stacked: undefined,
					stack: undefined,
					borderRadius: undefined,
				},
			]),
		);
	};
	_proto.prepareData = function prepareData(context, instance) {
		var data = instance.data;
		if (data.name && !data.colorName) data.colorName = data.name;
		_Widget.prototype.prepareData.call(this, context, instance);
	};
	_proto.explore = function explore(context, instance) {
		instance.xAxis = context.axes[this.xAxis];
		instance.yAxis = context.axes[this.yAxis];
		var data = instance.data;
		instance.colorMap = data.colorMap && context.getColorMap && context.getColorMap(data.colorMap);
		if (instance.colorMap && data.colorName) instance.colorMap.acknowledge(data.colorName);
		_Widget.prototype.explore.call(this, context, instance);
	};
	_proto.prepare = function prepare(context, instance) {
		var _this = this;
		var data = instance.data,
			colorMap = instance.colorMap,
			xAxis = instance.xAxis,
			yAxis = instance.yAxis;
		if (colorMap && data.name) {
			data.colorIndex = colorMap.map(data.colorName);
			if (instance.cache("colorIndex", data.colorIndex)) instance.markShouldUpdate(context);
		}
		if (xAxis.shouldUpdate || yAxis.shouldUpdate) instance.markShouldUpdate(context);
		if (data.name && context.addLegendEntry)
			context.addLegendEntry(this.legend, {
				name: data.name,
				active: data.active,
				colorIndex: data.colorIndex,
				disabled: data.disabled,
				selected: this.selection.isInstanceSelected(instance),
				style: data.style,
				shape: this.legendShape,
				onClick: function onClick(e) {
					_this.onLegendClick(e, instance);
				},
			});
	};
	_proto.onLegendClick = function onLegendClick(e, instance) {
		var allActions = this.legendAction == "auto";
		var data = instance.data;
		if (allActions || this.legendAction == "toggle") instance.set("active", !data.active);
	};
	_proto.render = function render(context, instance, key) {
		var data = instance.data;
		return /*#__PURE__*/ jsx(
			"g",
			{
				className: data.classNames,
				children: data.active && this.renderGraph(context, instance),
			},
			key,
		);
	};
	_proto.handleClick = function handleClick(e, instance, point, index) {
		if (this.onClick && instance.invoke("onClick", e, instance, point, index) === false) return;
		if (!this.selection.isDummy)
			this.selection.select(instance.store, point, index, {
				toggle: e.ctrlKey,
			});
	};
	return ColumnBarGraphBase;
})(Widget);
ColumnBarGraphBase.prototype.xAxis = "x";
ColumnBarGraphBase.prototype.yAxis = "y";
ColumnBarGraphBase.prototype.xField = "x";
ColumnBarGraphBase.prototype.yField = "y";
ColumnBarGraphBase.prototype.colorIndexField = false;
ColumnBarGraphBase.prototype.size = 1;
ColumnBarGraphBase.prototype.legend = "legend";
ColumnBarGraphBase.prototype.legendAction = "auto";
ColumnBarGraphBase.prototype.legendShape = "rect";
ColumnBarGraphBase.prototype.stack = "stack";
ColumnBarGraphBase.prototype.stacked = false;
ColumnBarGraphBase.prototype.autoSize = 0;
ColumnBarGraphBase.prototype.offset = 0;
ColumnBarGraphBase.prototype.styled = true;
ColumnBarGraphBase.prototype.borderRadius = 0;

var ColumnGraph = /*#__PURE__*/ (function (_ColumnBarGraphBase) {
	function ColumnGraph() {
		return _ColumnBarGraphBase.apply(this, arguments) || this;
	}
	_inheritsLoose(ColumnGraph, _ColumnBarGraphBase);
	var _proto = ColumnGraph.prototype;
	_proto.explore = function explore(context, instance) {
		var _this = this;
		_ColumnBarGraphBase.prototype.explore.call(this, context, instance);
		var data = instance.data,
			xAxis = instance.xAxis,
			yAxis = instance.yAxis;
		if (isArray(data.data)) {
			data.data.forEach(function (p, index) {
				var y0 = _this.y0Field ? p[_this.y0Field] : data.y0;
				var x = p[_this.xField];
				var y = p[_this.yField];
				xAxis.acknowledge(x, data.size, data.offset);
				if (data.autoSize) xAxis.book(x, data.stacked ? data.stack : data.name);
				if (data.stacked) {
					yAxis.stacknowledge(data.stack, x, y0);
					yAxis.stacknowledge(data.stack, x, y);
				} else {
					if (!_this.hiddenBase) yAxis.acknowledge(y0);
					yAxis.acknowledge(y);
				}
			});
		}
	};
	_proto.prepare = function prepare(context, instance) {
		var _this2 = this;
		_ColumnBarGraphBase.prototype.prepare.call(this, context, instance);
		var data = instance.data;
		if (context.pointReducer && isArray(data.data)) {
			data.data.forEach(function (p, index) {
				context.pointReducer(p[_this2.xField], p[_this2.yField], data.name, p, data.data, index);
			});
		}
	};
	_proto.renderGraph = function renderGraph(context, instance) {
		var _this3 = this;
		var data = instance.data,
			xAxis = instance.xAxis,
			yAxis = instance.yAxis,
			store = instance.store;
		if (!isArray(data.data)) return false;
		var isSelected = this.selection.getIsSelectedDelegate(store);
		return data.data.map(function (p, i) {
			var _state;
			var offset = data.offset,
				size = data.size;
			var y0 = _this3.y0Field ? p[_this3.y0Field] : data.y0;
			var x = p[_this3.xField];
			var y = p[_this3.yField];
			if (data.autoSize) {
				var _instance$xAxis$locat = instance.xAxis.locate(x, data.stacked ? data.stack : data.name),
					index = _instance$xAxis$locat[0],
					count = _instance$xAxis$locat[1];
				offset = (size / count) * (index - count / 2 + 0.5);
				size = size / count;
			}
			var x1 = xAxis.map(x, offset - size / 2);
			var x2 = xAxis.map(x, offset + size / 2);
			var y1 = data.stacked ? yAxis.stack(data.stack, x, y0) : yAxis.map(y0);
			var y2 = data.stacked ? yAxis.stack(data.stack, x, y) : yAxis.map(y);
			var color = _this3.colorIndexField ? p[_this3.colorIndexField] : data.colorIndex;
			var state =
				((_state = {
					selected: isSelected(p, i),
					selectable: !_this3.selection.isDummy,
				}),
				(_state["color-" + color] = color != null),
				_state);
			var mmove, mleave;
			if (_this3.tooltip) {
				mmove = function mmove(e) {
					return tooltipMouseMove(e, instance, _this3.tooltip, {
						target: e.target.parent,
						data: {
							$record: p,
						},
					});
				};
				mleave = function mleave(e) {
					return tooltipMouseLeave(e, instance, _this3.tooltip, {
						target: e.target.parent,
						data: {
							$record: p,
						},
					});
				};
			}
			return /*#__PURE__*/ jsx(
				"rect",
				{
					className: _this3.CSS.element(_this3.baseClass, "column", state),
					onClick: function onClick(e) {
						_this3.handleClick(e, instance, p, i);
					},
					x: Math.min(x1, x2),
					y: Math.min(y1, y2),
					width: Math.abs(x2 - x1),
					height: Math.abs(y2 - y1),
					style: data.style,
					onMouseMove: mmove,
					onMouseLeave: mleave,
					rx: data.borderRadius,
				},
				i,
			);
		});
	};
	return ColumnGraph;
})(ColumnBarGraphBase);
ColumnGraph.prototype.baseClass = "columngraph";
ColumnGraph.prototype.y0Field = false;
ColumnGraph.prototype.y0 = 0;
ColumnGraph.prototype.legendShape = "column";
ColumnGraph.prototype.hiddenBase = false;
Widget.alias("columngraph", ColumnGraph);

var BarGraph = /*#__PURE__*/ (function (_ColumnBarGraphBase) {
	function BarGraph() {
		return _ColumnBarGraphBase.apply(this, arguments) || this;
	}
	_inheritsLoose(BarGraph, _ColumnBarGraphBase);
	var _proto = BarGraph.prototype;
	_proto.explore = function explore(context, instance) {
		var _this = this;
		_ColumnBarGraphBase.prototype.explore.call(this, context, instance);
		var data = instance.data,
			yAxis = instance.yAxis,
			xAxis = instance.xAxis;
		if (isArray(data.data)) {
			data.data.forEach(function (p) {
				var x0 = _this.x0Field ? p[_this.x0Field] : data.x0;
				var y = p[_this.yField];
				var x = p[_this.xField];
				yAxis.acknowledge(y, data.size, data.offset);
				if (data.autoSize) yAxis.book(y, data.stacked ? data.stack : data.name);
				if (data.stacked) {
					xAxis.stacknowledge(data.stack, y, x0);
					xAxis.stacknowledge(data.stack, y, x);
				} else {
					if (!_this.hiddenBase) xAxis.acknowledge(x0);
					xAxis.acknowledge(x);
				}
			});
		}
	};
	_proto.renderGraph = function renderGraph(context, instance) {
		var _this2 = this;
		var data = instance.data,
			yAxis = instance.yAxis,
			xAxis = instance.xAxis,
			store = instance.store;
		if (!isArray(data.data)) return false;
		var isSelected = this.selection.getIsSelectedDelegate(store);
		return data.data.map(function (p, i) {
			var _state;
			var offset = data.offset,
				size = data.size;
			var x0 = _this2.x0Field ? p[_this2.x0Field] : data.x0;
			var y = p[_this2.yField];
			var x = p[_this2.xField];
			if (data.autoSize) {
				var _instance$yAxis$locat = instance.yAxis.locate(y, data.stacked ? data.stack : data.name),
					index = _instance$yAxis$locat[0],
					count = _instance$yAxis$locat[1];
				offset = (size / count) * (index - count / 2 + 0.5);
				size = size / count;
			}
			var y1 = yAxis.map(y, offset - size / 2);
			var y2 = yAxis.map(y, offset + size / 2);
			var x1 = data.stacked ? xAxis.stack(data.stack, y, x0) : xAxis.map(x0);
			var x2 = data.stacked ? xAxis.stack(data.stack, y, x) : xAxis.map(x);
			var color = _this2.colorIndexField ? p[_this2.colorIndexField] : data.colorIndex;
			var state =
				((_state = {
					selected: isSelected(p, i),
					selectable: !_this2.selection.isDummy,
				}),
				(_state["color-" + color] = color != null),
				_state);
			var mmove, mleave;
			if (_this2.tooltip) {
				mmove = function mmove(e) {
					return tooltipMouseMove(e, instance, _this2.tooltip, {
						target: e.target.parent,
						data: {
							$record: p,
						},
					});
				};
				mleave = function mleave(e) {
					return tooltipMouseLeave(e, instance, _this2.tooltip, {
						target: e.target.parent,
						data: {
							$record: p,
						},
					});
				};
			}
			return /*#__PURE__*/ jsx(
				"rect",
				{
					className: _this2.CSS.element(_this2.baseClass, "bar", state),
					onClick: function onClick(e) {
						_this2.handleClick(e, instance, p, i);
					},
					x: Math.min(x1, x2),
					y: Math.min(y1, y2),
					width: Math.abs(x2 - x1),
					height: Math.abs(y2 - y1),
					style: data.style,
					onMouseMove: mmove,
					onMouseLeave: mleave,
					rx: data.borderRadius,
				},
				i,
			);
		});
	};
	return BarGraph;
})(ColumnBarGraphBase);
BarGraph.prototype.baseClass = "bargraph";
BarGraph.prototype.x0Field = false;
BarGraph.prototype.x0 = 0;
BarGraph.prototype.legendShape = "bar";
BarGraph.prototype.hiddenBase = false;
BarGraph.prototype.borderRadius = 0;
Widget.alias("bargraph", BarGraph);

var ScatterGraph = /*#__PURE__*/ (function (_Widget) {
	function ScatterGraph() {
		return _Widget.apply(this, arguments) || this;
	}
	_inheritsLoose(ScatterGraph, _Widget);
	var _proto = ScatterGraph.prototype;
	_proto.init = function init() {
		this.selection = Selection.create(this.selection, {
			records: this.data,
		});
		_Widget.prototype.init.call(this);
	};
	_proto.declareData = function declareData() {
		var _Widget$prototype$dec;
		var selection = this.selection.configureWidget(this);
		(_Widget$prototype$dec = _Widget.prototype.declareData).call.apply(
			_Widget$prototype$dec,
			[this].concat(Array.prototype.slice.call(arguments), [
				{
					data: undefined,
					size: undefined,
					shape: undefined,
					colorIndex: undefined,
					colorMap: undefined,
					colorName: undefined,
					name: undefined,
					active: true,
				},
				selection,
			]),
		);
	};
	_proto.prepareData = function prepareData(context, instance) {
		var data = instance.data;
		if (data.name && !data.colorName) data.colorName = data.name;
		_Widget.prototype.prepareData.call(this, context, instance);
	};
	_proto.explore = function explore(context, instance) {
		var _this = this;
		_Widget.prototype.explore.call(this, context, instance);
		var xAxis = (instance.xAxis = context.axes[this.xAxis]);
		var yAxis = (instance.yAxis = context.axes[this.yAxis]);
		var data = instance.data;
		instance.colorMap = data.colorMap && context.getColorMap && context.getColorMap(data.colorMap);
		if (instance.colorMap && data.colorName) instance.colorMap.acknowledge(data.colorName);
		if (data.active && isArray(data.data)) {
			data.data.forEach(function (p) {
				xAxis.acknowledge(p[_this.xField]);
				yAxis.acknowledge(p[_this.yField]);
			});
		}
	};
	_proto.prepare = function prepare(context, instance) {
		var _this2 = this;
		var data = instance.data,
			xAxis = instance.xAxis,
			yAxis = instance.yAxis,
			colorMap = instance.colorMap;
		if (xAxis.shouldUpdate || yAxis.shouldUpdate) instance.markShouldUpdate(context);
		if (colorMap && data.name) {
			data.colorIndex = colorMap.map(data.colorName);
			if (instance.cache("colorIndex", data.colorIndex)) instance.markShouldUpdate(context);
		}
		if (data.name && context.addLegendEntry)
			context.addLegendEntry(this.legend, {
				name: data.name,
				active: data.active,
				colorIndex: data.colorIndex,
				disabled: data.disabled,
				style: data.style,
				shape: data.shape,
				onClick: function onClick(e) {
					_this2.onLegendClick(e, instance);
				},
			});
		if (data.active) {
			if (context.pointReducer && isArray(data.data)) {
				data.data.forEach(function (p, index) {
					context.pointReducer(p[_this2.xField], p[_this2.yField], data.name, p, data.data, index);
				});
			}
		}
	};
	_proto.onLegendClick = function onLegendClick(e, instance) {
		var allActions = this.legendAction == "auto";
		var data = instance.data;
		if (allActions || this.legendAction == "toggle") instance.set("active", !data.active);
	};
	_proto.render = function render(context, instance, key) {
		var data = instance.data;
		return /*#__PURE__*/ jsx(
			"g",
			{
				className: data.classNames,
				children: this.renderData(context, instance),
			},
			key,
		);
	};
	_proto.renderData = function renderData(context, instance) {
		var _this3 = this;
		var data = instance.data,
			xAxis = instance.xAxis,
			yAxis = instance.yAxis,
			store = instance.store;
		if (!data.active) return null;
		var shape = getShape(data.shape);
		var isSelected = this.selection.getIsSelectedDelegate(store);
		return (
			isArray(data.data) &&
			data.data.map(function (p, i) {
				var _CSS$element;
				var classes = CSS.element(
					_this3.baseClass,
					"shape",
					((_CSS$element = {
						selected: isSelected(p, i),
						selectable: !_this3.selection.isDummy,
					}),
					(_CSS$element["color-" + data.colorIndex] = data.colorIndex != null),
					_CSS$element),
				);
				var cx = xAxis.map(p[_this3.xField]),
					cy = yAxis.map(p[_this3.yField]),
					size = _this3.sizeField ? p[_this3.sizeField] : data.size;
				return shape(cx, cy, size, {
					key: i,
					className: classes,
					style: p.style || data.style,
					onClick: function onClick(e) {
						_this3.handleItemClick(e, instance, i);
					},
				});
			})
		);
	};
	_proto.handleItemClick = function handleItemClick(e, _ref, index) {
		var data = _ref.data,
			store = _ref.store;
		var bubble = data.data[index];
		this.selection.select(store, bubble, index, {
			toggle: e.ctrlKey,
		});
	};
	return ScatterGraph;
})(Widget);
ScatterGraph.prototype.baseClass = "scattergraph";
ScatterGraph.prototype.xAxis = "x";
ScatterGraph.prototype.yAxis = "y";
ScatterGraph.prototype.xField = "x";
ScatterGraph.prototype.yField = "y";
ScatterGraph.prototype.sizeField = false;
ScatterGraph.prototype.shape = "circle";
ScatterGraph.prototype.size = 10;
ScatterGraph.prototype.legend = "legend";
ScatterGraph.prototype.legendAction = "auto";
ScatterGraph.prototype.styled = true;
Widget.alias("scatter-graph", ScatterGraph);

var BubbleGraph = /*#__PURE__*/ (function (_Widget) {
	function BubbleGraph() {
		return _Widget.apply(this, arguments) || this;
	}
	_inheritsLoose(BubbleGraph, _Widget);
	var _proto = BubbleGraph.prototype;
	_proto.declareData = function declareData() {
		var _Widget$prototype$dec;
		var selection = this.selection.configureWidget(this);
		(_Widget$prototype$dec = _Widget.prototype.declareData).call.apply(
			_Widget$prototype$dec,
			[this].concat(Array.prototype.slice.call(arguments), [
				{
					data: undefined,
					bubbleRadius: undefined,
					bubbleStyle: {
						structured: true,
					},
				},
				selection,
			]),
		);
	};
	_proto.init = function init() {
		this.selection = Selection.create(this.selection, {
			records: this.data,
		});
		_Widget.prototype.init.call(this);
	};
	_proto.explore = function explore(context, instance) {
		var _this = this;
		instance.axes = context.axes;
		_Widget.prototype.explore.call(this, context, instance);
		var data = instance.data;
		if (isArray(data.data)) {
			data.data.forEach(function (p) {
				instance.axes[_this.xAxis].acknowledge(p[_this.xField]);
				instance.axes[_this.yAxis].acknowledge(p[_this.yField]);
			});
		}
	};
	_proto.prepare = function prepare(context, instance) {
		_Widget.prototype.prepare.call(this, context, instance);
		if (instance.axes[this.xAxis].shouldUpdate || instance.axes[this.yAxis].shouldUpdate)
			instance.markShouldUpdate(context);
	};
	_proto.render = function render(context, instance, key) {
		var data = instance.data;
		return /*#__PURE__*/ jsx(
			"g",
			{
				className: data.classNames,
				children: this.renderData(context, instance),
			},
			key,
		);
	};
	_proto.renderData = function renderData(context, instance) {
		var _this2 = this;
		var data = instance.data,
			axes = instance.axes,
			store = instance.store;
		var xAxis = axes[this.xAxis];
		var yAxis = axes[this.yAxis];
		return (
			isArray(data.data) &&
			data.data.map(function (p, i) {
				var selected = _this2.selection && _this2.selection.isSelected(store, p, i);
				var classes = CSS.element(_this2.baseClass, "bubble", {
					selected: selected,
				});
				return /*#__PURE__*/ jsx(
					"circle",
					{
						className: classes,
						cx: xAxis.map(p[_this2.xField]),
						cy: yAxis.map(p[_this2.yField]),
						r: p[_this2.rField] || data.bubbleRadius,
						style: p.style || data.bubbleStyle,
						onClick: function onClick(e) {
							_this2.onBubbleClick(e, instance, i);
						},
					},
					i,
				);
			})
		);
	};
	_proto.onBubbleClick = function onBubbleClick(e, _ref, index) {
		var data = _ref.data,
			store = _ref.store;
		var bubble = data.data[index];
		this.selection.select(store, bubble, index, {
			toggle: e.ctrlKey,
		});
	};
	return BubbleGraph;
})(Widget);
BubbleGraph.prototype.baseClass = "bubblegraph";
BubbleGraph.prototype.xAxis = "x";
BubbleGraph.prototype.yAxis = "y";
BubbleGraph.prototype.xField = "x";
BubbleGraph.prototype.yField = "y";
BubbleGraph.prototype.rField = "r";
BubbleGraph.prototype.bubbleRadius = 10;
Widget.alias("bubble-graph", BubbleGraph);

var MouseTracker = /*#__PURE__*/ (function (_BoundedObject) {
	function MouseTracker() {
		return _BoundedObject.apply(this, arguments) || this;
	}
	_inheritsLoose(MouseTracker, _BoundedObject);
	var _proto = MouseTracker.prototype;
	_proto.declareData = function declareData() {
		var _BoundedObject$protot;
		return (_BoundedObject$protot = _BoundedObject.prototype.declareData).call.apply(
			_BoundedObject$protot,
			[this].concat(Array.prototype.slice.call(arguments), [
				{
					x: undefined,
					y: undefined,
				},
			]),
		);
	};
	_proto.explore = function explore(context, instance) {
		instance.xAxis = context.axes[this.xAxis];
		instance.yAxis = context.axes[this.yAxis];
		_BoundedObject.prototype.explore.call(this, context, instance);
	};
	_proto.render = function render(context, instance, key) {
		var _this = this;
		var data = instance.data;
		var bounds = data.bounds;
		if (!bounds.valid()) return null;
		return /*#__PURE__*/ jsxs(
			"g",
			{
				className: data.classNames,
				onMouseMove: function onMouseMove(e) {
					_this.handleMouseMove(e, instance);
				},
				onMouseLeave: function onMouseLeave(e) {
					_this.handleMouseLeave(e, instance);
				},
				children: [
					/*#__PURE__*/ jsx("rect", {
						x: bounds.l,
						y: bounds.t,
						width: bounds.width(),
						height: bounds.height(),
						fill: "transparent",
						strokeWidth: "0",
					}),
					this.renderChildren(context, instance),
				],
			},
			key,
		);
	};
	_proto.handleMouseMove = function handleMouseMove(e, instance) {
		var xAxis = instance.xAxis,
			yAxis = instance.yAxis;
		var svgEl = closest(e.target, function (el) {
			return el.tagName == "svg";
		});
		var bounds = getTopLevelBoundingClientRect(svgEl);
		if (xAxis) instance.set("x", xAxis.trackValue(e.clientX - bounds.left));
		if (yAxis) instance.set("y", yAxis.trackValue(e.clientY - bounds.top));
		tooltipMouseMove(e, instance, instance.widget.tooltip);
	};
	_proto.handleMouseLeave = function handleMouseLeave(e, instance) {
		var xAxis = instance.xAxis,
			yAxis = instance.yAxis;
		tooltipMouseLeave(e, instance, instance.widget.tooltip);
		if (xAxis) instance.set("x", null);
		if (yAxis) instance.set("y", null);
	};
	return MouseTracker;
})(BoundedObject);
MouseTracker.prototype.xAxis = "x";
MouseTracker.prototype.yAxis = "y";
MouseTracker.prototype.anchors = "0 1 1 0";
MouseTracker.prototype.baseClass = "mousetracker";

var Stack = /*#__PURE__*/ (function () {
	function Stack() {
		this.reset();
	}
	var _proto = Stack.prototype;
	_proto.reset = function reset() {
		this.stacks = {};
		this.values = {};
		this.normalized = false;
		this.invalid = {};
	};
	_proto.acknowledge = function acknowledge(ordinal, value) {
		if (value != null) {
			var s = this.stacks[ordinal];
			if (!s)
				this.stacks[ordinal] = s = {
					total: 0,
					min: 0,
					max: 0,
				};
			s.total += value;
			if (s.total < s.min) s.min = s.total;
			if (s.total > s.max) s.max = s.total;
		} else {
			this.invalid[ordinal] = true;
		}
	};
	_proto.measure = function measure(normalized) {
		if (normalized) {
			this.normalized = true;
			return [0, 1];
		}
		var max = 0,
			min = 0;
		for (var key in this.stacks) {
			if (this.stacks[key].max > max) max = this.stacks[key].max;
			if (this.stacks[key].min < min) min = this.stacks[key].min;
		}
		return [min, max];
	};
	_proto.stack = function stack(ordinal, value) {
		if (value == null || this.invalid[ordinal]) return null;
		var base = this.values[ordinal] || 0;
		var result = (this.values[ordinal] = base + value);
		if (!this.normalized) return result;
		var total = this.stacks[ordinal].total;
		if (total > 0) return result / total;
		return null;
	};
	return Stack;
})();

var NumericAxis = /*#__PURE__*/ (function (_Axis) {
	function NumericAxis() {
		return _Axis.apply(this, arguments) || this;
	}
	_inheritsLoose(NumericAxis, _Axis);
	var _proto = NumericAxis.prototype;
	_proto.init = function init() {
		if (this.deadZone) {
			this.lowerDeadZone = this.deadZone;
			this.upperDeadZone = this.deadZone;
		}
		_Axis.prototype.init.call(this);
	};
	_proto.declareData = function declareData() {
		var _Axis$prototype$decla;
		(_Axis$prototype$decla = _Axis.prototype.declareData).call.apply(
			_Axis$prototype$decla,
			[this].concat(Array.prototype.slice.call(arguments), [
				{
					min: undefined,
					max: undefined,
					normalized: undefined,
					inverted: undefined,
					labelDivisor: undefined,
					format: undefined,
					lowerDeadZone: undefined,
					upperDeadZone: undefined,
				},
			]),
		);
	};
	_proto.initInstance = function initInstance(context, instance) {
		instance.calculator = new NumericScale();
	};
	_proto.explore = function explore(context, instance) {
		_Axis.prototype.explore.call(this, context, instance);
		var _instance$data = instance.data,
			min = _instance$data.min,
			max = _instance$data.max,
			normalized = _instance$data.normalized,
			inverted = _instance$data.inverted,
			lowerDeadZone = _instance$data.lowerDeadZone,
			upperDeadZone = _instance$data.upperDeadZone;
		instance.calculator.reset(
			min,
			max,
			this.snapToTicks,
			this.tickDivisions,
			this.minTickDistance,
			this.minTickStep,
			this.minLabelDistance,
			this.minLabelTickSize,
			normalized,
			inverted,
			lowerDeadZone,
			upperDeadZone,
		);
	};
	_proto.render = function render(context, instance, key) {
		var data = instance.data;
		if (!data.bounds.valid()) return null;
		var baseFormatter = Format.parse(data.format);
		var formatter =
			data.labelDivisor != 1
				? function (v) {
						return baseFormatter(v / data.labelDivisor);
					}
				: baseFormatter;
		return /*#__PURE__*/ jsx(
			"g",
			{
				className: data.classNames,
				style: data.style,
				children: this.renderTicksAndLabels(context, instance, formatter, this.minLabelDistance),
			},
			key,
		);
	};
	NumericAxis.XY = function XY() {
		return {
			x: {
				type: NumericAxis,
			},
			y: {
				type: NumericAxis,
				vertical: true,
			},
		};
	};
	return NumericAxis;
})(Axis);
NumericAxis.prototype.baseClass = "numericaxis";
NumericAxis.prototype.tickDivisions = [
	[1, 2, 10, 20, 100],
	[1, 5, 10, 20, 100],
];
NumericAxis.prototype.snapToTicks = 1;
NumericAxis.prototype.normalized = false;
NumericAxis.prototype.format = "n";
NumericAxis.prototype.labelDivisor = 1;
NumericAxis.prototype.minLabelTickSize = 0;
NumericAxis.prototype.minTickStep = 0;
Axis.alias("numeric", NumericAxis);
var NumericScale = /*#__PURE__*/ (function () {
	function NumericScale() {}
	var _proto2 = NumericScale.prototype;
	_proto2.reset = function reset(
		min,
		max,
		snapToTicks,
		tickDivisions,
		minTickDistance,
		minTickStep,
		minLabelDistance,
		minLabelTickSize,
		normalized,
		inverted,
		lowerDeadZone,
		upperDeadZone,
	) {
		this.min = min;
		this.max = max;
		this.snapToTicks = snapToTicks;
		this.tickDivisions = tickDivisions;
		this.minLabelDistance = minLabelDistance;
		this.minLabelTickSize = minLabelTickSize;
		this.minTickDistance = minTickDistance;
		this.minTickStep = minTickStep;
		this.tickSizes = [];
		this.normalized = normalized;
		this.inverted = inverted;
		delete this.minValue;
		delete this.maxValue;
		this.stacks = {};
		this.lowerDeadZone = lowerDeadZone || 0;
		this.upperDeadZone = upperDeadZone || 0;
	};
	_proto2.map = function map(v, offset) {
		if (offset === void 0) {
			offset = 0;
		}
		return this.origin + (v + offset - this.scale.min + this.scale.minPadding) * this.scale.factor;
	};
	_proto2.decodeValue = function decodeValue(n) {
		return n;
	};
	_proto2.encodeValue = function encodeValue(v) {
		return v;
	};
	_proto2.constrainValue = function constrainValue(v) {
		return Math.max(this.scale.min, Math.min(this.scale.max, v));
	};
	_proto2.trackValue = function trackValue(v, offset, constrain) {
		if (offset === void 0) {
			offset = 0;
		}
		if (constrain === void 0) {
			constrain = false;
		}
		var value = (v - this.origin) / this.scale.factor - offset + this.scale.min - this.scale.minPadding;
		if (constrain) value = this.constrainValue(v);
		return value;
	};
	_proto2.hash = function hash() {
		var _this = this;
		var r = {
			origin: this.origin,
			factor: this.scale.factor,
			min: this.scale.min,
			max: this.scale.max,
			minPadding: this.scale.minPadding,
			maxPadding: this.scale.maxPadding,
		};
		r.stacks = Object.keys(this.stacks)
			.map(function (s) {
				var _this$stacks$s$info;
				return (_this$stacks$s$info = _this.stacks[s].info) == null ? void 0 : _this$stacks$s$info.join(",");
			})
			.join(":");
		return r;
	};
	_proto2.isSame = function isSame(x) {
		var hash = this.hash();
		var same =
			x &&
			!Object.keys(hash).some(function (k) {
				return x[k] !== hash[k];
			});
		this.shouldUpdate = !same;
		return same;
	};
	_proto2.measure = function measure(a, b) {
		this.a = a;
		this.b = b;
		if (this.minValue != null && this.min == null) this.min = this.minValue;
		if (this.maxValue != null && this.max == null) this.max = this.maxValue;
		for (var s in this.stacks) {
			var info = this.stacks[s].measure(this.normalized);
			var min = info[0],
				max = info[1];
			info[2];
			if (this.min == null || min < this.min) this.min = min;
			if (this.max == null || max > this.max) this.max = max;
			this.stacks[s].info = info;
		}
		if (this.min == null) this.min = 0;
		if (this.max == null) this.max = this.normalized ? 1 : 100;
		if (this.min == this.max) {
			if (this.min == 0) {
				this.min = -1;
				this.max = 1;
			} else {
				var delta = Math.abs(this.min) * 0.1;
				this.min -= delta;
				this.max += delta;
			}
		}
		this.origin = this.inverted ? this.b : this.a;
		this.scale = this.getScale();
		this.calculateTicks();
	};
	_proto2.getScale = function getScale(tickSizes) {
		var min = this.min,
			max = this.max;
		var smin = min;
		var smax = max;
		var tickSize;
		if (tickSizes && isNumber(this.snapToTicks) && tickSizes.length > 0) {
			tickSize = tickSizes[Math.min(tickSizes.length - 1, this.snapToTicks)];
			smin = Math.floor(smin / tickSize) * tickSize;
			smax = Math.ceil(smax / tickSize) * tickSize;
		} else {
			if (this.minValue === min) smin = this.minValuePadded;
			if (this.maxValue === max) smax = this.maxValuePadded;
		}
		var minPadding = this.minValue === min ? Math.max(0, smin - this.minValuePadded) : 0;
		var maxPadding = this.maxValue === max ? Math.max(0, this.maxValuePadded - smax) : 0;
		var sign = this.b > this.a ? 1 : -1;
		var factor =
			smin < smax
				? (Math.abs(this.b - this.a) - this.lowerDeadZone - this.upperDeadZone) /
					(smax - smin + minPadding + maxPadding)
				: 0;
		if (factor < 0) factor = 0;
		if (factor > 0 && (this.lowerDeadZone > 0 || this.upperDeadZone > 0)) {
			while (factor * (min - smin) < this.lowerDeadZone) smin -= this.lowerDeadZone / factor;
			while (factor * (smax - max) < this.upperDeadZone) smax += this.upperDeadZone / factor;
			if (tickSize > 0 && isNumber(this.snapToTicks)) {
				smin = Math.floor(smin / tickSize) * tickSize;
				smax = Math.ceil(smax / tickSize) * tickSize;
				minPadding = this.minValue === min ? Math.max(0, smin - this.minValuePadded) : 0;
				maxPadding = this.maxValue === max ? Math.max(0, this.maxValuePadded - smax) : 0;
			}
			factor = smin < smax ? Math.abs(this.b - this.a) / (smax - smin + minPadding + maxPadding) : 0;
		}
		return {
			factor: sign * (this.inverted ? -factor : factor),
			min: smin,
			max: smax,
			minPadding: minPadding,
			maxPadding: maxPadding,
		};
	};
	_proto2.acknowledge = function acknowledge(value, width, offset) {
		if (width === void 0) {
			width = 0;
		}
		if (offset === void 0) {
			offset = 0;
		}
		if (value == null) return;
		if (this.minValue == null || value < this.minValue) {
			this.minValue = value;
			this.minValuePadded = value + offset - width / 2;
		}
		if (this.maxValue == null || value > this.maxValue) {
			this.maxValue = value;
			this.maxValuePadded = value + offset + width / 2;
		}
	};
	_proto2.getStack = function getStack(name) {
		var s = this.stacks[name];
		if (!s) s = this.stacks[name] = new Stack();
		return s;
	};
	_proto2.stacknowledge = function stacknowledge(name, ordinal, value) {
		return this.getStack(name).acknowledge(ordinal, value);
	};
	_proto2.stack = function stack(name, ordinal, value) {
		var v = this.getStack(name).stack(ordinal, value);
		return v != null ? this.map(v) : null;
	};
	_proto2.findTickSize = function findTickSize(minPxDist) {
		var _this2 = this;
		return this.tickSizes.find(function (a) {
			return a >= _this2.minLabelTickSize && a * Math.abs(_this2.scale.factor) >= minPxDist;
		});
	};
	_proto2.getTickSizes = function getTickSizes() {
		return this.tickSizes;
	};
	_proto2.calculateTicks = function calculateTicks() {
		var _this3 = this;
		var dist = this.minLabelDistance / Math.abs(this.scale.factor);
		var unit = Math.pow(10, Math.floor(Math.log10(dist)));
		var bestLabelDistance = Infinity;
		var bestTicks = [];
		var bestScale = this.scale;
		var _loop = function _loop() {
			var divs = _this3.tickDivisions[i];
			var tickSizes = divs
				.filter(function (ts) {
					return ts >= _this3.minTickStep;
				})
				.map(function (ts) {
					return ts * unit;
				});
			var scale = _this3.getScale(tickSizes);
			tickSizes.forEach(function (size, level) {
				var labelDistance = size * Math.abs(scale.factor);
				if (labelDistance >= _this3.minLabelDistance && labelDistance < bestLabelDistance) {
					bestScale = scale;
					bestTicks = tickSizes;
					bestLabelDistance = labelDistance;
				}
			});
		};
		for (var i = 0; i < this.tickDivisions.length; i++) {
			_loop();
		}
		this.scale = bestScale;
		this.tickSizes = bestTicks.filter(function (ts) {
			return ts >= _this3.minTickStep && ts * Math.abs(bestScale.factor) >= _this3.minTickDistance;
		});
		if (this.tickSizes.length > 0) {
			var max = this.tickSizes[this.tickSizes.length - 1];
			this.tickSizes.push(2 * max);
			this.tickSizes.push(5 * max);
			this.tickSizes.push(10 * max);
			var min = this.tickSizes[0];
			var _dist = min * Math.abs(bestScale.factor) >= this.minTickDistance;
			if (min / 10 >= this.minTickStep && _dist / 10 >= this.minTickDistance) this.tickSizes.splice(0, 0, min / 10);
			else if (min / 5 >= this.minTickStep && _dist / 5 >= this.minTickDistance) this.tickSizes.splice(0, 0, min / 5);
			else if (min / 2 >= this.minTickStep && _dist / 2 >= this.minTickDistance) this.tickSizes.splice(0, 0, min / 2);
		}
	};
	_proto2.getTicks = function getTicks(tickSizes) {
		var _this4 = this;
		return tickSizes.map(function (size) {
			var start = Math.ceil((_this4.scale.min - _this4.scale.minPadding) / size);
			var end = Math.floor((_this4.scale.max + _this4.scale.maxPadding) / size);
			var result = [];
			for (var i = start; i <= end; i++) result.push(i * size + 0);
			return result;
		});
	};
	_proto2.mapGridlines = function mapGridlines() {
		var size = this.tickSizes[0];
		var start = Math.ceil((this.scale.min - this.scale.minPadding) / size);
		var end = Math.floor((this.scale.max + this.scale.maxPadding) / size);
		var result = [];
		for (var i = start; i <= end; i++) result.push(this.map(i * size));
		return result;
	};
	_proto2.book = function book() {
		Console.warn("NumericAxis does not support the autoSize flag for column and bar graphs.");
	};
	return NumericScale;
})();

var CategoryAxis = /*#__PURE__*/ (function (_Axis) {
	function CategoryAxis() {
		return _Axis.apply(this, arguments) || this;
	}
	_inheritsLoose(CategoryAxis, _Axis);
	var _proto = CategoryAxis.prototype;
	_proto.declareData = function declareData() {
		var _Axis$prototype$decla;
		(_Axis$prototype$decla = _Axis.prototype.declareData).call.apply(
			_Axis$prototype$decla,
			[this].concat(Array.prototype.slice.call(arguments), [
				{
					inverted: undefined,
					uniform: undefined,
					names: undefined,
					values: undefined,
					minSize: undefined,
					categoryCount: undefined,
					format: undefined,
				},
			]),
		);
	};
	_proto.initInstance = function initInstance(context, instance) {
		instance.calculator = new CategoryScale();
	};
	_proto.explore = function explore(context, instance) {
		_Axis.prototype.explore.call(this, context, instance);
		var _instance$data = instance.data,
			values = _instance$data.values,
			names = _instance$data.names,
			inverted = _instance$data.inverted,
			uniform = _instance$data.uniform,
			minSize = _instance$data.minSize;
		instance.calculator.reset(inverted, uniform, values, names, minSize, this.minTickDistance, this.minLabelDistance);
	};
	_proto.reportData = function reportData(context, instance) {
		instance.set("categoryCount", instance.calculator.valueList.length);
	};
	_proto.render = function render(context, instance, key) {
		var data = instance.data,
			calculator = instance.calculator;
		if (!data.bounds.valid()) return null;
		var labelGetter = function labelGetter(v) {
			var _calculator$names$v;
			return (_calculator$names$v = calculator.names[v]) != null ? _calculator$names$v : v;
		};
		var labelFormatter = labelGetter;
		if (data.format) {
			var formatter = Format.parse(data.format);
			labelFormatter = function labelFormatter(v) {
				return formatter(labelGetter(v));
			};
		}
		return /*#__PURE__*/ jsx(
			"g",
			{
				className: data.classNames,
				style: data.style,
				children: this.renderTicksAndLabels(context, instance, labelFormatter),
			},
			key,
		);
	};
	return CategoryAxis;
})(Axis);
CategoryAxis.prototype.baseClass = "categoryaxis";
CategoryAxis.prototype.anchors = "0 1 1 0";
CategoryAxis.prototype.vertical = false;
CategoryAxis.prototype.inverted = false;
CategoryAxis.prototype.uniform = false;
CategoryAxis.prototype.labelOffset = 10;
CategoryAxis.prototype.labelRotation = 0;
CategoryAxis.prototype.labelAnchor = "auto";
CategoryAxis.prototype.labelDx = "auto";
CategoryAxis.prototype.labelDy = "auto";
CategoryAxis.prototype.minSize = 1;
CategoryAxis.prototype.minLabelDistanceHorizontal = 0;
CategoryAxis.prototype.minLabelDistanceVertical = 0;
CategoryAxis.prototype.minTickDistance = 0;
Axis.alias("category", CategoryAxis);
var CategoryScale = /*#__PURE__*/ (function () {
	function CategoryScale() {}
	var _proto2 = CategoryScale.prototype;
	_proto2.reset = function reset(inverted, uniform, values, names, minSize, minTickDistance, minLabelDistance) {
		var _this = this;
		this.padding = 0.5;
		delete this.min;
		delete this.max;
		delete this.minValue;
		delete this.maxValue;
		this.minSize = minSize;
		this.valuesMap = {};
		this.valueList = [];
		this.inverted = inverted;
		this.uniform = uniform;
		this.valueStacks = {};
		this.names = {};
		this.minTickDistance = minTickDistance;
		this.minLabelDistance = minLabelDistance;
		if (values) {
			if (isArray(values))
				values.forEach(function (v) {
					return _this.acknowledge(v);
				});
			else if (typeof values == "object")
				for (var k in values) {
					this.acknowledge(k);
					this.names[k] = values[k];
				}
		}
		if (names) {
			if (isArray(names)) {
				values = values || [];
				names.forEach(function (name, index) {
					var value = values[index];
					_this.names[value != null ? value : index] = name;
				});
			} else this.names = names;
		}
	};
	_proto2.decodeValue = function decodeValue(n) {
		return n;
	};
	_proto2.encodeValue = function encodeValue(v) {
		return v;
	};
	_proto2.map = function map(v, offset) {
		if (offset === void 0) {
			offset = 0;
		}
		var index = this.valuesMap[v] || 0;
		return this.origin + (index + offset - this.min + this.padding) * this.factor;
	};
	_proto2.measure = function measure(a, b) {
		this.a = a;
		this.b = b;
		if (this.min == null) this.min = this.minValue || 0;
		if (this.max == null) this.max = !isNaN(this.maxValue) ? this.maxValue : 100;
		var sign = this.inverted ? -1 : 1;
		if (this.max - this.min + 1 < this.minSize) {
			this.factor = (sign * (this.b - this.a)) / this.minSize;
			this.origin = (this.b + this.a) * 0.5 - (this.factor * (this.max - this.min + 1)) / 2;
		} else {
			this.factor = (sign * (this.b - this.a)) / (this.max - this.min + 2 * this.padding);
			this.origin = (this.a * (1 + sign)) / 2 + (this.b * (1 - sign)) / 2; //a || b
		}
		this.tickSizes = [];
		var tickMultiplier = [1, 2, 5];
		var absFactor = Math.abs(this.factor);
		for (var base = 1; base < 10000 && this.tickSizes.length < 2; base *= 10) {
			for (var _iterator = _createForOfIteratorHelperLoose(tickMultiplier), _step; !(_step = _iterator()).done; ) {
				var m = _step.value;
				if (base * m * absFactor >= this.minTickDistance && this.tickSizes.length == 0) this.tickSizes.push(base * m);
				if (base * m * absFactor >= this.minLabelDistance) {
					this.tickSizes.push(base * m);
					break;
				}
			}
		}
	};
	_proto2.hash = function hash() {
		return {
			origin: this.origin,
			factor: this.factor,
			min: this.min,
			minSize: this.minSize,
			padding: this.padding,
			values: this.valueList.join(":"),
			names: JSON.stringify(this.names),
		};
	};
	_proto2.isSame = function isSame(x) {
		var h = this.hash();
		var same =
			x &&
			!Object.keys(h).some(function (k) {
				return x[k] !== h[k];
			});
		this.shouldUpdate = !same;
		return same;
	};
	_proto2.acknowledge = function acknowledge(value, width, offset) {
		if (width === void 0) {
			width = 0;
		}
		if (offset === void 0) {
			offset = 0;
		}
		var index = this.valuesMap[value];
		if (isUndefined(index)) {
			index = this.valueList.length;
			this.valueList.push(value);
			this.valuesMap[value] = index;
		}
		if (this.minValue == null || index < this.minValue) {
			this.minValue = index;
			this.padding = Math.max(this.padding, Math.abs(offset - width / 2));
		}
		if (this.maxValue == null || index > this.maxValue) {
			this.maxValue = index;
			this.padding = Math.max(this.padding, Math.abs(offset + width / 2));
		}
	};
	_proto2.book = function book(value, name) {
		if (this.uniform) value = 0;
		var stack = this.valueStacks[value];
		if (!stack)
			stack = this.valueStacks[value] = {
				index: {},
				count: 0,
			};
		if (!stack.index.hasOwnProperty(name)) stack.index[name] = stack.count++;
	};
	_proto2.locate = function locate(value, name) {
		if (this.uniform) value = 0;
		var stack = this.valueStacks[value];
		if (!stack) return [0, 1];
		return [stack.index[name], stack.count];
	};
	_proto2.trackValue = function trackValue(v, offset, constrain) {
		if (offset === void 0) {
			offset = 0;
		}
		var index = Math.round((v - this.origin) / this.factor - offset + this.min - this.padding);
		if (index < this.min) index = this.min;
		if (index > this.max) index = this.max;
		return this.valueList[index];
	};
	_proto2.findTickSize = function findTickSize(minPxDist) {
		for (var _iterator2 = _createForOfIteratorHelperLoose(this.tickSizes), _step2; !(_step2 = _iterator2()).done; ) {
			var tickSize = _step2.value;
			if (tickSize * Math.abs(this.factor) >= minPxDist) return tickSize;
		}
		return 1;
	};
	_proto2.getTickSizes = function getTickSizes() {
		return this.tickSizes;
	};
	_proto2.getTicks = function getTicks(tickSizes) {
		var _this2 = this;
		return tickSizes.map(function (size) {
			return _this2.valueList.filter(function (_, i) {
				return i % size == 0;
			});
		});
	};
	_proto2.mapGridlines = function mapGridlines() {
		var result = [];
		if (this.tickSizes.length == 0) return result;
		var step = this.tickSizes[0];
		for (var index = this.min; index <= this.max + 1; index += step)
			result.push(this.origin + (index - 0.5 - this.min + this.padding) * this.factor);
		return result;
	};
	return CategoryScale;
})();

var _TimeAxis$prototype$m;
Format$1.registerFactory("yearOrMonth", function (format) {
	var year = Format$1.parse("datetime;yyyy");
	var month = Format$1.parse("datetime;MMM");
	return function (date) {
		var d = new Date(date);
		if (d.getMonth() == 0) return year(d);
		else return month(d);
	};
});
Format$1.registerFactory("monthOrDay", function (format) {
	var month = Format$1.parse("datetime;MMM");
	var day = Format$1.parse("datetime;dd");
	return function (date) {
		var d = new Date(date);
		if (d.getDate() == 1) return month(d);
		else return day(d);
	};
});
var TimeAxis = /*#__PURE__*/ (function (_Axis) {
	function TimeAxis() {
		return _Axis.apply(this, arguments) || this;
	}
	_inheritsLoose(TimeAxis, _Axis);
	var _proto = TimeAxis.prototype;
	_proto.init = function init() {
		if (this.labelAnchor == "auto") this.labelAnchor = this.vertical ? (this.secondary ? "start" : "end") : "start";
		if (this.labelDx == "auto") this.labelDx = this.vertical ? 0 : "5px";
		if (this.deadZone) {
			this.lowerDeadZone = this.deadZone;
			pperDeadZone = this.deadZone;
		}
		this.minLabelDistanceFormatOverride = _extends(
			{},
			this.minLabelDistanceFormatOverrideDefaults,
			this.minLabelDistanceFormatOverride,
		);
		_Axis.prototype.init.call(this);
	};
	_proto.declareData = function declareData() {
		var _Axis$prototype$decla;
		(_Axis$prototype$decla = _Axis.prototype.declareData).call.apply(
			_Axis$prototype$decla,
			[this].concat(Array.prototype.slice.call(arguments), [
				{
					anchors: undefined,
					min: undefined,
					max: undefined,
					inverted: undefined,
					lowerDeadZone: undefined,
					upperDeadZone: undefined,
				},
			]),
		);
	};
	_proto.initInstance = function initInstance(context, instance) {
		instance.calculator = new TimeScale();
	};
	_proto.explore = function explore(context, instance) {
		_Axis.prototype.explore.call(this, context, instance);
		var _instance$data = instance.data,
			min = _instance$data.min,
			max = _instance$data.max,
			normalized = _instance$data.normalized,
			inverted = _instance$data.inverted,
			lowerDeadZone = _instance$data.lowerDeadZone,
			upperDeadZone = _instance$data.upperDeadZone;
		instance.calculator.reset(
			min,
			max,
			this.snapToTicks,
			this.tickDivisions,
			Math.max(1, this.minTickDistance),
			Math.max(1, this.minLabelDistance),
			normalized,
			inverted,
			this.minTickUnit,
			lowerDeadZone,
			upperDeadZone,
			this.decode,
			this.useLabelDistanceFormatOverrides ? this.minLabelDistanceFormatOverride : {},
			this.format,
		);
	};
	_proto.render = function render(context, instance, key) {
		var data = instance.data,
			cached = instance.cached,
			calculator = instance.calculator;
		cached.axis = calculator.hash();
		if (!data.bounds.valid()) return null;
		var format = calculator.resolvedFormat;
		var minLabelDistance = calculator.resolvedMinLabelDistance;
		var formatter = Format$1.parse(format);
		return /*#__PURE__*/ jsx(
			"g",
			{
				className: data.classNames,
				style: data.style,
				children: this.renderTicksAndLabels(context, instance, formatter, minLabelDistance),
			},
			key,
		);
	};
	return TimeAxis;
})(Axis);
Axis.alias("time", TimeAxis);
TimeAxis.prototype.baseClass = "timeaxis";
TimeAxis.prototype.tickDivisions = {
	second: [[1, 5, 15, 30]],
	minute: [[1, 5, 15, 30]],
	hour: [
		[1, 2, 4, 8],
		[1, 3, 6, 12],
	],
	day: [[1]],
	week: [[1]],
	month: [[1, 3, 6]],
	year: [
		[1, 2, 10],
		[1, 5, 10],
		[5, 10, 50],
		[10, 50, 100],
	],
};
var TimeFormats = {
	fullDateAndTime: "datetime;yyyy MMM dd HH mm ss n",
	shortMonthDate: "datetime;yyyy MMM dd",
};
TimeAxis.prototype.snapToTicks = 0;
TimeAxis.prototype.tickSize = 15;
TimeAxis.prototype.minLabelDistance = 60;
TimeAxis.prototype.minTickDistance = 60;
TimeAxis.prototype.minTickUnit = "second";
TimeAxis.prototype.useLabelDistanceFormatOverrides = false;
TimeAxis.prototype.minLabelDistanceFormatOverrideDefaults =
	((_TimeAxis$prototype$m = {}),
	(_TimeAxis$prototype$m[TimeFormats.fullDateAndTime] = 150),
	(_TimeAxis$prototype$m[TimeFormats.shortMonthDate] = 90),
	_TimeAxis$prototype$m);
function monthNumber(date) {
	return date.getFullYear() * 12 + date.getMonth() + (date.getDate() - 1) / 31;
}
function yearNumber(date) {
	return monthNumber(date) / 12;
}
var miliSeconds = {
	second: 1000,
	minute: 60 * 1000,
	hour: 3600 * 1000,
	day: 3600 * 24 * 1000,
	week: 3600 * 24 * 7 * 1000,
	month: 3600 * 24 * 30 * 1000,
	year: 3600 * 24 * 365 * 1000,
};
var TimeScale = /*#__PURE__*/ (function () {
	function TimeScale() {}
	var _proto2 = TimeScale.prototype;
	_proto2.reset = function reset(
		min,
		max,
		snapToTicks,
		tickDivisions,
		minTickDistance,
		minLabelDistance,
		normalized,
		inverted,
		minTickUnit,
		lowerDeadZone,
		upperDeadZone,
		decode,
		minLabelDistanceFormatOverride,
		format,
	) {
		this.dateCache = {};
		this.min = min != null ? this.decodeValue(min) : null;
		this.max = max != null ? this.decodeValue(max) : null;
		this.snapToTicks = snapToTicks;
		this.tickDivisions = tickDivisions;
		this.minLabelDistance = minLabelDistance;
		this.minTickDistance = minTickDistance;
		this.tickSizes = [];
		this.normalized = normalized;
		this.minTickUnit = minTickUnit;
		this.inverted = inverted;
		this.lowerDeadZone = lowerDeadZone || 0;
		this.upperDeadZone = upperDeadZone || 0;
		delete this.minValue;
		delete this.maxValue;
		delete this.minValuePadded;
		delete this.maxValuePadded;
		this.stacks = {};
		this.decode = decode;
		this.minLabelDistanceFormatOverride = minLabelDistanceFormatOverride;
		this.format = format;
	};
	_proto2.decodeValue = function decodeValue(date) {
		if (date instanceof Date) return date.getTime();
		switch (typeof date) {
			case "string":
				var v = this.dateCache[date];
				if (!v) {
					if (this.decode) date = this.decode(date);
					v = this.dateCache[date] = Date.parse(date);
				}
				return v;
			case "number":
				return date;
		}
	};
	_proto2.encodeValue = function encodeValue(v) {
		return new Date(v).toISOString();
	};
	_proto2.getFormat = function getFormat(unit, scale) {
		switch (unit) {
			case "year":
				return "datetime;yyyy";
			case "month":
				if (new Date(scale.min).getFullYear() != new Date(scale.max).getFullYear()) return "yearOrMonth";
				return "datetime;yyyy MMM";
			case "week":
				return "datetime;MMMdd";
			case "day":
				if (
					new Date(scale.min).getFullYear() != new Date(scale.max).getFullYear() ||
					new Date(scale.min).getMonth() != new Date(scale.max).getMonth()
				)
					return "monthOrDay";
				return TimeFormats.shortMonthDate;
			case "hour":
				return "datetime;HH mm n";
			case "minute":
				return "datetime;HH mm n";
			case "second":
				return "datetime;mm ss";
			default:
				return TimeFormats.fullDateAndTime;
		}
	};
	_proto2.map = function map(v, offset) {
		if (offset === void 0) {
			offset = 0;
		}
		return this.origin + (this.decodeValue(v) + offset - this.scale.min + this.scale.minPadding) * this.scale.factor;
	};
	_proto2.constrainValue = function constrainValue(v) {
		return Math.max(this.scale.min, Math.min(this.scale.max, v));
	};
	_proto2.trackValue = function trackValue(v, offset, constrain) {
		if (offset === void 0) {
			offset = 0;
		}
		if (constrain === void 0) {
			constrain = false;
		}
		var value = (v - this.origin) / this.scale.factor - offset + this.scale.min - this.scale.minPadding;
		if (constrain) value = this.constrainValue(value);
		return value;
	};
	_proto2.hash = function hash() {
		var _this = this;
		var r = {
			origin: this.origin,
			factor: this.scale.factor,
			min: this.scale.min,
			max: this.scale.max,
			minPadding: this.scale.minPadding,
			maxPadding: this.scale.maxPadding,
		};
		r.stacks = Object.keys(this.stacks)
			.map(function (s) {
				return _this.stacks[s].info.join(",");
			})
			.join(":");
		return r;
	};
	_proto2.isSame = function isSame(x) {
		var hash = this.hash();
		var same =
			x &&
			!Object.keys(hash).some(function (k) {
				return x[k] !== hash[k];
			});
		this.shouldUpdate = !same;
		return same;
	};
	_proto2.measure = function measure(a, b) {
		this.a = a;
		this.b = b;
		for (var s in this.stacks) {
			var info = this.stacks[s].measure(this.normalized);
			var min = info[0],
				max = info[1];
			info[2];
			if (this.minValue == null || min < this.minValue) this.minValue = min;
			if (this.max == null || max > this.maxValue) this.maxValue = max;
			this.stacks[s].info = info;
		}
		if (this.min == null) {
			if (this.minValue != null) this.min = this.minValue;
			else this.min = 0;
		}
		if (this.max == null) {
			if (this.maxValue != null) this.max = this.maxValue;
			else this.max = this.normalized ? 1 : 100;
		}
		this.origin = this.inverted ? this.b : this.a;
		this.calculateTicks();
		if (this.scale == null) {
			this.scale = this.getScale();
		}
	};
	_proto2.getTimezoneOffset = function getTimezoneOffset(date) {
		return date.getTimezoneOffset() * 60 * 1000;
	};
	_proto2.getScale = function getScale(tickSize, measure, minRange) {
		if (minRange === void 0) {
			minRange = 1000;
		}
		var min = this.min,
			max = this.max,
			upperDeadZone = this.upperDeadZone,
			lowerDeadZone = this.lowerDeadZone;
		var smin = min;
		var smax = max;
		if (tickSize) {
			var minDate = new Date(min);
			var maxDate = new Date(max);
			switch (measure) {
				case "second":
				case "minute":
				case "hour":
				case "day":
				default:
					var minOffset = this.getTimezoneOffset(minDate);
					var maxOffset = this.getTimezoneOffset(maxDate);
					var mondayOffset = 4 * miliSeconds.day; //new Date(0).getDay() => 4
					smin = Math.floor((smin - minOffset - mondayOffset) / tickSize) * tickSize + minOffset + mondayOffset;
					smax = Math.ceil((smax - maxOffset - mondayOffset) / tickSize) * tickSize + maxOffset + mondayOffset;
					break;
				case "month":
					tickSize /= miliSeconds.month;
					var minMonth = monthNumber(minDate);
					var maxMonth = monthNumber(maxDate);
					minMonth = Math.floor(minMonth / tickSize) * tickSize;
					maxMonth = Math.ceil(maxMonth / tickSize) * tickSize;
					smin = new Date(Math.floor(minMonth / 12), minMonth % 12, 1).getTime();
					smax = new Date(Math.floor(maxMonth / 12), maxMonth % 12, 1).getTime();
					break;
				case "year":
					tickSize /= miliSeconds.year;
					var minYear = yearNumber(minDate);
					var maxYear = yearNumber(maxDate);
					minYear = Math.floor(minYear / tickSize) * tickSize;
					maxYear = Math.ceil(maxYear / tickSize) * tickSize;
					smin = new Date(minYear, 0, 1).getTime();
					smax = new Date(maxYear, 0, 1).getTime();
					break;
			}
		} else {
			if (this.minValue == min) smin = this.minValuePadded;
			if (this.maxValue == max) smax = this.maxValuePadded;
		}
		if (smax - smin < minRange) {
			var delta = (minRange - (smax - smin)) / 2;
			smin -= delta;
			smax += delta;
		}

		//padding should be activated only if using min/max obtained from the data
		var minPadding = this.minValue === min ? Math.max(0, smin - this.minValuePadded) : 0;
		var maxPadding = this.maxValue === max ? Math.max(0, this.maxValuePadded - smax) : 0;
		var factor = smin < smax ? Math.abs(this.b - this.a) / (smax - smin + minPadding + maxPadding) : 0;
		if (factor > 0 && (upperDeadZone > 0 || lowerDeadZone > 0)) {
			smin -= lowerDeadZone / factor;
			smax += upperDeadZone / factor;
			minPadding = this.minValuePadded != null ? Math.max(0, smin - this.minValuePadded) : 0;
			maxPadding = this.maxValuePadded != null ? Math.max(0, this.maxValuePadded - smax) : 0;
			factor = smin < smax ? Math.abs(this.b - this.a) / (smax - smin + minPadding + maxPadding) : 0;
		}
		var sign = this.b > this.a ? 1 : -1;
		return {
			factor: sign * (this.inverted ? -factor : factor),
			min: smin,
			max: smax,
			minPadding: minPadding,
			maxPadding: maxPadding,
		};
	};
	_proto2.acknowledge = function acknowledge(value, width, offset) {
		if (width === void 0) {
			width = 0;
		}
		if (offset === void 0) {
			offset = 0;
		}
		value = this.decodeValue(value);
		if (this.minValue == null || value + offset - width / 2 < this.minValuePadded) {
			this.minValue = value;
			this.minValuePadded = value + offset - width / 2;
		}
		if (this.maxValue == null || value + offset + width / 2 > this.maxValuePadded) {
			this.maxValue = value;
			this.maxValuePadded = value + offset + width / 2;
		}
	};
	_proto2.getStack = function getStack(name) {
		var s = this.stacks[name];
		if (!s) s = this.stacks[name] = new Stack();
		return s;
	};
	_proto2.stacknowledge = function stacknowledge(name, ordinal, value) {
		return this.getStack(name).acknowledge(ordinal, value);
	};
	_proto2.stack = function stack(name, ordinal, value) {
		var v = this.getStack(name).stack(ordinal, value);
		return v != null ? this.map(v) : null;
	};
	_proto2.findTickSize = function findTickSize(minPxDist) {
		var _this2 = this;
		return this.tickSizes.find(function (_ref) {
			var size = _ref.size,
				noLabels = _ref.noLabels;
			return !noLabels && size * Math.abs(_this2.scale.factor) >= minPxDist;
		});
	};
	_proto2.getTickSizes = function getTickSizes() {
		return this.tickSizes;
	};
	_proto2.calculateTicks = function calculateTicks() {
		var _this3 = this;
		var minReached = false;
		var minRange = 1000;
		var _loop = function _loop(unit) {
				if (!minReached) {
					if (unit == _this3.minTickUnit) minReached = true;
					else return 0; // continue
				}
				var unitSize = miliSeconds[unit];
				var divisions = _this3.tickDivisions[unit];
				if (_this3.tickSizes.length > 0) {
					var _this3$tickSizes;
					//add ticks from higher levels
					(_this3$tickSizes = _this3.tickSizes).push.apply(
						_this3$tickSizes,
						divisions[0].map(function (s) {
							return {
								size: s * unitSize,
								measure: unit,
							};
						}),
					);
					return 1; // break
				}
				var bestLabelDistance = Infinity;
				var bestMinLabelDistance = _this3.minLabelDistance;
				var bestTicks = [];
				var bestScale = null;
				var bestFormat = null;
				_this3.tickMeasure = unit;
				for (var _i = 0; _i < divisions.length; _i++) {
					var _divs = divisions[_i];
					for (var _d = 0; _d < _divs.length; _d++) {
						var _this3$format, _this3$minLabelDistan;
						//if (useSnapToTicks && d < Math.min(divs.length - 1, this.snapToTicks)) continue;
						var _tickSize2 = _divs[_d] * unitSize;
						var scale = _this3.getScale(null, unit, _tickSize2);
						var format = (_this3$format = _this3.format) != null ? _this3$format : _this3.getFormat(unit, scale);
						var minLabelDistance =
							(_this3$minLabelDistan = _this3.minLabelDistanceFormatOverride[format]) != null
								? _this3$minLabelDistan
								: _this3.minLabelDistance;
						var labelDistance = _tickSize2 * Math.abs(scale.factor);
						if (labelDistance >= minLabelDistance && labelDistance < bestLabelDistance) {
							bestScale = scale;
							bestTicks = _divs.map(function (s) {
								return s * unitSize;
							});
							bestLabelDistance = labelDistance;
							bestFormat = format;
							bestMinLabelDistance = minLabelDistance;
							minRange = _tickSize2;
						}
					}
				}
				_this3.scale = bestScale;
				_this3.tickSizes = bestTicks
					.filter(function (ts) {
						return ts * Math.abs(bestScale.factor) >= _this3.minTickDistance;
					})
					.map(function (size) {
						return {
							size: size,
							measure: _this3.tickMeasure,
						};
					});
				_this3.resolvedFormat = bestFormat;
				_this3.resolvedMinLabelDistance = bestMinLabelDistance;
			},
			_ret;
		for (var unit in miliSeconds) {
			_ret = _loop(unit);
			if (_ret === 0) continue;
			if (_ret === 1) break;
		}
		var lowerTickUnit = null;
		switch (this.tickMeasure) {
			case "year":
				lowerTickUnit = "month";
				break;
			case "month":
				lowerTickUnit = "day";
				break;
			case "week":
				lowerTickUnit = "day";
				break;
			case "day":
				lowerTickUnit = "hour";
				break;
			case "hour":
				lowerTickUnit = "minute";
				break;
			case "minute":
				lowerTickUnit = "second";
				break;
		}
		if (lowerTickUnit && this.minTickUnit && miliSeconds[lowerTickUnit] < miliSeconds[this.minTickUnit])
			lowerTickUnit = this.minTickUnit == this.tickMeasure ? null : this.minTickUnit;
		if (lowerTickUnit != null && this.scale) {
			var bestMinorTickSize = Infinity;
			var divisions = this.tickDivisions[lowerTickUnit];
			var unitSize = miliSeconds[lowerTickUnit];
			for (var i = 0; i < divisions.length; i++) {
				var divs = divisions[i];
				for (var d = 0; d < divs.length; d++) {
					var tickSize = divs[d] * unitSize;
					if (tickSize * Math.abs(this.scale.factor) >= this.minTickDistance && tickSize < bestMinorTickSize) {
						bestMinorTickSize = tickSize;
					}
				}
			}
			if (bestMinorTickSize != Infinity) {
				this.tickSizes.unshift({
					size: bestMinorTickSize,
					measure: lowerTickUnit,
					noLabels: true,
				});
				if (this.tickSizes.length > 1) {
					var labelStep = this.tickSizes[1].size;
					var lowerScale = this.getScale(null, lowerTickUnit, minRange);
					if (lowerScale.max - lowerScale.min >= labelStep) this.scale = lowerScale;
				}
			}
		}
		if (isNumber(this.snapToTicks) && this.snapToTicks >= 0 && this.tickSizes.length > 0) {
			var _tickSize = this.tickSizes[Math.min(this.tickSizes.length - 1, this.snapToTicks)];
			this.scale = this.getScale(_tickSize.size, _tickSize.measure, minRange);
		}
	};
	_proto2.getTicks = function getTicks(tickSizes) {
		var _this4 = this;
		return tickSizes.map(function (_ref2) {
			var size = _ref2.size,
				measure = _ref2.measure;
			var result = [],
				start,
				end,
				minDate,
				maxDate;
			if (measure == "year") {
				size /= miliSeconds.year;
				minDate = new Date(_this4.scale.min - _this4.scale.minPadding);
				maxDate = new Date(_this4.scale.max + _this4.scale.maxPadding);
				start = Math.ceil(yearNumber(minDate) / size) * size;
				end = Math.floor(yearNumber(maxDate) / size) * size;
				for (var i = start; i <= end; i += size) result.push(new Date(i, 0, 1).getTime());
			} else if (measure == "month") {
				size /= miliSeconds.month;
				minDate = new Date(_this4.scale.min - _this4.scale.minPadding);
				maxDate = new Date(_this4.scale.max + _this4.scale.maxPadding);
				start = Math.ceil(monthNumber(minDate) / size) * size;
				end = Math.floor(monthNumber(maxDate) / size) * size;
				for (var _i2 = start; _i2 <= end; _i2 += size)
					result.push(new Date(Math.floor(_i2 / 12), _i2 % 12, 1).getTime());
			} else if (measure == "day" || measure == "week") {
				var multiplier = measure == "week" ? 7 : 1;
				size /= miliSeconds.day;
				minDate = new Date(_this4.scale.min - _this4.scale.minPadding);
				maxDate = new Date(_this4.scale.max + _this4.scale.maxPadding);
				var date = zeroTime(minDate);
				while (date.getTime() < minDate.getTime()) date.setDate(date.getDate() + 1);
				if (measure == "week") {
					//start on monday
					while (date.getDay() != 1) {
						date.setDate(date.getDate() + 1);
					}
				}
				while (date.getTime() <= maxDate.getTime()) {
					result.push(date);
					date = new Date(date);
					date.setDate(date.getDate() + multiplier);
				}
			} else {
				var minOffset = _this4.getTimezoneOffset(new Date(_this4.scale.min - _this4.scale.minPadding));
				var mondayOffset = 4 * miliSeconds.day;
				var _date =
					Math.ceil((_this4.scale.min - _this4.scale.minPadding - minOffset - mondayOffset) / size) * size +
					minOffset +
					mondayOffset;
				while (_date <= _this4.scale.max + _this4.scale.maxPadding) {
					result.push(_date);
					_date += size;
				}
			}
			return result;
		});
	};
	_proto2.mapGridlines = function mapGridlines() {
		var _this5 = this;
		if (this.tickSizes.length == 0) return [];
		return this.getTicks([this.tickSizes[0]])[0].map(function (x) {
			return _this5.map(x);
		});
	};
	_proto2.book = function book() {
		Console$1.warn("TimeAxis does not support the autoSize flag for column and bar graphs.");
	};
	return TimeScale;
})();

var PointReducer = /*#__PURE__*/ (function (_PureContainer) {
	function PointReducer() {
		return _PureContainer.apply(this, arguments) || this;
	}
	_inheritsLoose(PointReducer, _PureContainer);
	var _proto = PointReducer.prototype;
	_proto.explore = function explore(context, instance) {
		var _this = this;
		var parentPointReducer = context.pointReducer;
		instance.parentPointTracker = parentPointReducer;
		if (!instance.pointReducer) {
			var onMap = this.onMap && instance.getCallback("onMap");
			var accumulator = {};
			instance.resetAccumulator = function () {
				accumulator = {};
				if (_this.onInitAccumulator) instance.invoke("onInitAccumulator", accumulator, instance);
			};
			var pointFilter = null;
			if (this.onCreatePointFilter) pointFilter = instance.invoke("onCreatePointFilter", instance);
			instance.pointReducer = function (x, y, name, data, array, index) {
				if (!pointFilter || pointFilter(x, y, name, data, array, index))
					onMap(accumulator, x, y, name, data, array, index);
				if (parentPointReducer) parentPointReducer(x, y, name, data, array, index);
			};
			instance.write = function () {
				if (_this.onReduce) instance.invoke("onReduce", accumulator, instance);
			};
		}
		instance.resetAccumulator();
		context.push("pointReducer", instance.pointReducer);
		_PureContainer.prototype.explore.call(this, context, instance);
	};
	_proto.exploreCleanup = function exploreCleanup(context, instance) {
		context.pop("pointReducer");
	};
	_proto.prepare = function prepare(context, instance) {
		context.push("pointReducer", instance.pointReducer);
	};
	_proto.prepareCleanup = function prepareCleanup(context, instance) {
		context.pop("pointReducer");
		instance.write();
	};
	return PointReducer;
})(PureContainer);

var MinMaxFinder = /*#__PURE__*/ (function (_PointReducer) {
	function MinMaxFinder() {
		return _PointReducer.apply(this, arguments) || this;
	}
	_inheritsLoose(MinMaxFinder, _PointReducer);
	var _proto = MinMaxFinder.prototype;
	_proto.declareData = function declareData() {
		var _PointReducer$prototy;
		return (_PointReducer$prototy = _PointReducer.prototype.declareData).call.apply(
			_PointReducer$prototy,
			[this].concat(Array.prototype.slice.call(arguments), [
				{
					minX: undefined,
					minY: undefined,
					maxX: undefined,
					maxY: undefined,
					params: {
						structured: true,
					},
				},
			]),
		);
	};
	_proto.onInitAccumulator = function onInitAccumulator(acc, _ref) {
		var data = _ref.data;
		acc.params = data.params;
		acc.min = {
			x: null,
			y: null,
		};
		acc.max = {
			x: null,
			y: null,
		};
	};
	_proto.onMap = function onMap(acc, x, y, name, p) {
		if (y != null && (acc.max.y == null || acc.max.y < y))
			acc.max = {
				x: x,
				y: y,
				p: p,
			};
		if (y != null && (acc.min.y == null || acc.min.y > y))
			acc.min = {
				x: x,
				y: y,
				p: p,
			};
	};
	_proto.onReduce = function onReduce(acc, instance) {
		instance.set("minX", acc.min.x);
		instance.set("minY", acc.min.y);
		instance.set("minRecord", acc.min.p);
		instance.set("maxX", acc.max.x);
		instance.set("maxY", acc.max.y);
		instance.set("maxRecord", acc.max.p);
	};
	return MinMaxFinder;
})(PointReducer);

var SnapPointFinder = /*#__PURE__*/ (function (_PointReducer) {
	function SnapPointFinder() {
		return _PointReducer.apply(this, arguments) || this;
	}
	_inheritsLoose(SnapPointFinder, _PointReducer);
	var _proto = SnapPointFinder.prototype;
	_proto.declareData = function declareData() {
		var _PointReducer$prototy;
		return (_PointReducer$prototy = _PointReducer.prototype.declareData).call.apply(
			_PointReducer$prototy,
			[this].concat(Array.prototype.slice.call(arguments), [
				{
					cursorX: undefined,
					cursorY: undefined,
					snapX: undefined,
					snapY: undefined,
					snapRecord: undefined,
					maxDistance: undefined,
				},
			]),
		);
	};
	_proto.explore = function explore(context, instance) {
		instance.xAxis = context.axes[this.xAxis];
		instance.yAxis = context.axes[this.yAxis];
		_PointReducer.prototype.explore.call(this, context, instance);
	};
	_proto.onInitAccumulator = function onInitAccumulator(acc, _ref) {
		var data = _ref.data,
			xAxis = _ref.xAxis,
			yAxis = _ref.yAxis;
		acc.cursor = {
			x: data.cursorX,
			y: data.cursorY,
			mapped: false,
		};
		acc.dist = data.maxDistance > 0 ? Math.pow(data.maxDistance, 2) : Number.POSITIVE_INFINITY;
		acc.snapX = null;
		acc.snapY = null;
		acc.xAxis = xAxis;
		acc.yAxis = yAxis;
	};
	_proto.onMap = function onMap(acc, x, y, name, p) {
		var xAxis = acc.xAxis,
			yAxis = acc.yAxis,
			cursor = acc.cursor;
		if (!cursor.mapped) {
			cursor.mappedX = cursor.x != null ? (xAxis == null ? void 0 : xAxis.map(this.convertX(cursor.x))) : null;
			cursor.mappedY = cursor.y != null ? (yAxis == null ? void 0 : yAxis.map(this.convertY(cursor.y))) : null;
			cursor.mapped = true;
		}
		var d = null;
		var cx = x != null ? (xAxis == null ? void 0 : xAxis.map(this.convertX(x))) : null;
		var cy = y != null ? (yAxis == null ? void 0 : yAxis.map(this.convertY(y))) : null;
		if (cursor.mappedX != null && cx != null) d = (d || 0) + Math.pow(Math.abs(cx - cursor.mappedX), 2);
		if (cursor.mappedY != null && cy != null) d = (d || 0) + Math.pow(Math.abs(cy - cursor.mappedY), 2);
		if (d != null && d < acc.dist) {
			acc.dist = d;
			acc.snapX = x;
			acc.snapY = y;
			acc.snapRecord = p;
		}
	};
	_proto.onReduce = function onReduce(acc, instance) {
		instance.set("snapX", acc.snapX);
		instance.set("snapY", acc.snapY);
		instance.set("snapRecord", acc.snapRecord);
	};
	return SnapPointFinder;
})(PointReducer);
SnapPointFinder.prototype.maxDistance = 50;
SnapPointFinder.prototype.convertX = function (x) {
	return x;
};
SnapPointFinder.prototype.convertY = function (y) {
	return y;
};
SnapPointFinder.prototype.xAxis = "x";
SnapPointFinder.prototype.yAxis = "y";

var ValueAtFinder = /*#__PURE__*/ (function (_PointReducer) {
	function ValueAtFinder() {
		return _PointReducer.apply(this, arguments) || this;
	}
	_inheritsLoose(ValueAtFinder, _PointReducer);
	var _proto = ValueAtFinder.prototype;
	_proto.declareData = function declareData() {
		var _PointReducer$prototy;
		return (_PointReducer$prototy = _PointReducer.prototype.declareData).call.apply(
			_PointReducer$prototy,
			[this].concat(Array.prototype.slice.call(arguments), [
				{
					at: undefined,
					value: undefined,
				},
			]),
		);
	};
	_proto.onInitAccumulator = function onInitAccumulator(acc, _ref) {
		var data = _ref.data;
		acc.at = this.convert(data.at);
	};
	_proto.onMap = function onMap(acc, x, y, name) {
		var cx = this.convert(x);
		var d = cx - acc.at;
		if (d <= 0 && (!acc.left || acc.left.d < d)) {
			acc.left = {
				x: cx,
				y: y,
				d: d,
			};
		}
		if (d >= 0 && (!acc.right || acc.right.d > d)) {
			acc.right = {
				x: cx,
				y: y,
				d: d,
			};
		}
	};
	_proto.onReduce = function onReduce(acc, instance) {
		var y = null;
		if (acc.left && acc.right) {
			if (acc.left.x == acc.right.x) y = acc.left.y;
			else if (acc.left.y != null && acc.right.y != null) {
				y = acc.left.y + ((acc.right.y - acc.left.y) * (acc.at - acc.left.x)) / (acc.right.x - acc.left.x);
			}
		}
		instance.set("value", y);
	};
	return ValueAtFinder;
})(PointReducer);
ValueAtFinder.prototype.convert = function (x) {
	return x;
};

export {
	Axis,
	Bar,
	BarGraph,
	BubbleGraph,
	CategoryAxis,
	Chart,
	ColorIndex,
	ColorMap,
	ColorMapScope,
	Column,
	ColumnGraph,
	Gridlines,
	Legend,
	LegendEntry,
	LegendScope,
	LineGraph,
	Marker,
	MarkerLine,
	MinMaxFinder,
	MouseTracker,
	NumericAxis,
	Pie,
	PieChart,
	PieLabel,
	PieLabelsContainer,
	PieSlice,
	PointReducer,
	Range,
	RangeMarker,
	ScatterGraph,
	SnapPointFinder,
	Swimlane,
	Swimlanes,
	TimeAxis,
	ValueAtFinder,
	bar,
	circle,
	column,
	getAvailableShapes,
	getShape,
	line,
	registerShape,
	square,
	triangle,
	vline,
};
